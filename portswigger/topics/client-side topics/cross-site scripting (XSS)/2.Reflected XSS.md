
https://portswigger.net/web-security/cross-site-scripting/reflected

---
# What is reflected cross-site scripting?
Reflected cross-site scripting (or XSS) arises when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way.

Suppose a website has a search function which receives the user-supplied search term in a URL parameter:
```http
https://insecure-website.com/search?term=gift
```
The application echoes the supplied search term in the response to this URL:
```http
<p>You searched for: gift</p>
```
Assuming the application doesn't perform any other processing of the data, an attacker can construct an attack like this:
```http
https://insecure-website.com/search?term=<script>/*+Bad+stuff+here...+*/</script>
```
This URL results in the following response:
```http
<p>You searched for: <script>/* Bad stuff here... */</script></p>
```
==If another user of the application requests the attacker's URL, then the script supplied by the attacker will execute in the victim user's browser, in the context of their session with the application==.


# LAP
```http
https://0a28006704fe040e804cb77400a50051.web-security-academy.net/?search=%3Cscript%3Ealert%28%27...%21%27%29%3B%3C%2Fscript%3E
```


# Reflected XSS in different contexts
The location of the reflected data within the application's response determines what type of payload is required to exploit it and might also affect the impact of the vulnerability.

In addition, if the application performs any validation or other processing on the submitted data before it is reflected, this will generally affect what kind of XSS payload is needed.


# How to find and test for reflected XSS vulnerabilities
**Test every entry point.**
Test separately every entry point for data within the application's 
HTTP requests.

This includes parameters or other data within the URL query string and message body, and the URL file path. 

It also includes HTTP headers, although XSS-like behavior that can only be triggered via certain HTTP headers may not be exploitable in practice.


**Submit random alphanumeric values.**
For each entry point, submit a unique random value and determine whether the value is reflected in the response. 

The value should be designed to survive most input validation, so needs to be fairly short and contain only alphanumeric characters. But it needs to be long enough to make accidental matches within the response highly unlikely. 

A random alphanumeric value of around 8 characters is normally ideal. 

You can use Burp Intruder's [number payloads](https://portswigger.net/burp/documentation/desktop/tools/intruder/payloads/types#numbers) with randomly generated hex values to generate suitable random values. 

And you can use Burp Intruder's [grep payloads settings](https://portswigger.net/burp/documentation/desktop/tools/intruder/configure-attack/settings#grep-payloads) to automatically flag responses that contain the submitted value.


**Test a candidate payload.** 
Based on the context of the reflection, test an initial candidate XSS payload that will trigger JavaScript execution if it is reflected unmodified within the response. 

The easiest way to test payloads is to send the request to [Burp Repeater](https://portswigger.net/burp/documentation/desktop/tools/repeater), modify the request to insert the candidate payload, issue the request, and then review the response to see if the payload worked. 

**==An efficient way to work is to leave the original random value in the request and place the candidate XSS payload before or after it==**. 

Then set the random value as the search term in Burp Repeater's response view.


# Common questions

**What is the difference between reflected XSS and stored XSS?** **==Reflected XSS arises when an application takes some input from an HTTP request and embeds that input into the immediate response in an unsafe way==**.


