https://portswigger.net/web-security/cross-site-scripting#what-is-cross-site-scripting-xss

---
# What is cross-site scripting (XSS)?
Cross-site scripting (also known as XSS) is a web security vulnerability that allows an attacker to [compromise](https://translate.google.com/?sl=en&tl=ar&text=compromise&op=translate) the interactions that users have with a vulnerable application.

It allows an attacker to [circumvent](https://translate.google.com/?sl=en&tl=ar&text=circumvent&op=translate) the same origin policy, which is designed to [segregate](https://translate.google.com/?sl=en&tl=ar&text=segregate&op=translate) different websites from each other.

Cross-site scripting vulnerabilities normally allow an attacker to [masquerade](https://translate.google.com/?sl=en&tl=ar&text=masquerade&op=translate) as a victim user, to carry out any actions that the user is able to perform, and to access any of the user's data.



# How does XSS work?
Cross-site scripting works by manipulating a vulnerable web site so that it returns malicious JavaScript to users. 

When the malicious code executes inside a victim's browser, the attacker can fully compromise their interaction with the application.


![[cross-site-scripting.svg]]



# XSS proof of concept
It's long been common practice to use the `alert()` function for this purpose because it's short, harmless, and pretty hard to miss when it's successfully called.

As these are used to construct some of the more advanced XSS attacks, you'll sometimes need to use an alternative PoC payload. In this scenario, we recommend the `print()` function. 

If you're interested in learning more about this change and why we like `print()`, [check out our blog post](https://portswigger.net/research/alert-is-dead-long-live-print) on the subject.


# What are the types of XSS attacks?
- [Reflected XSS](https://portswigger.net/web-security/cross-site-scripting#reflected-cross-site-scripting), where the malicious script comes from the current HTTP request.

- [Stored XSS](https://portswigger.net/web-security/cross-site-scripting#stored-cross-site-scripting), where the malicious script comes from the website's database.

- [DOM-based XSS](https://portswigger.net/web-security/cross-site-scripting#dom-based-cross-site-scripting), where the vulnerability exists in client-side code rather than server-side code.


## Reflected cross-site scripting
Reflected XSS is the simplest variety of cross-site scripting. 

It [arises](https://translate.google.com/?sl=en&tl=ar&text=arises&op=translate) when an application receives data in an HTTP request and includes that data within the immediate response in an unsafe way.

Here is a simple example of a reflected XSS vulnerability:
```http
https://insecure-website.com/status?message=All+is+well.
<p>Status: All is well.</p>
```
The application doesn't perform any other processing of the data, so an attacker can easily construct an attack like this:
```http
https://insecure-website.com/status?message=<script>/*+Bad+stuff+here...+*/</script>
<p>Status: <script>/* Bad stuff here... */</script></p>
```
If the user visits the URL constructed by the attacker, then the attacker's script executes in the user's browser, in the context of that user's session with the application.



## Stored cross-site scripting
Stored XSS (also known as persistent or second-order XSS) arises when an application receives data from an untrusted source and includes that data within its later HTTP responses in an unsafe way.

The data in question might be submitted to the application via HTTP requests; for example, comments on a blog post, user nicknames in a chat room, or contact details on a customer order.

**Here is a simple example of a stored XSS vulnerability**. 
A message board application lets users submit messages, which are displayed to other users:
```html
<p>Hello, this is my message!</p>
```
The application doesn't perform any other processing of the data, so an attacker can easily send a message that attacks other users:
```html
<p><script>/* Bad stuff here... */</script></p>
```



## DOM-based cross-site scripting
DOM-based XSS (also known as DOM XSS) arises when an application contains some client-side JavaScript that processes data from an untrusted source in an unsafe way, usually by writing the data back to the DOM.

In the following example, an application uses some JavaScript to read the value from an input field and write that value to an element within the HTML:
```js
var search = document.getElementById('search').value;
var results = document.getElementById('results');
results.innerHTML = 'You searched for: ' + search;
```
If the attacker can control the value of the input field, they can easily construct a malicious value that causes their own script to execute:
```html
You searched for: <img src=1 onerror='/* Bad stuff here... */'>
```



# What can XSS be used for?
An attacker who exploits a cross-site scripting vulnerability is typically able to:
- Impersonate or masquerade as the victim user.
- Carry out any action that the user is able to perform.
- Read any data that the user is able to access.
- ==Capture the user's login credentials==.
- Perform virtual defacement of the web site.
- ==Inject trojan functionality into the web site==.



# How to find and test for XSS vulnerabilities
Burp Suite's web vulnerability scanner combines static and dynamic analysis of JavaScript to reliably automate the detection of DOM-based vulnerabilities.



# How to prevent XSS attacks
- **Filter input on arrival.** At the point where user input is received, filter as strictly as possible based on what is expected or valid input.

- **Encode data on output.** At the point where user-controllable data is output in HTTP responses, encode the output to prevent it from being interpreted as active content. Depending on the output context, this might require applying combinations of HTML, URL, JavaScript, and CSS encoding.

- **Use appropriate response headers.** To prevent XSS in HTTP responses that aren't intended to contain any HTML or JavaScript, you can use the `Content-Type` and `X-Content-Type-Options` headers to ensure that browsers interpret the responses in the way you intend.

- **Content Security Policy.** As a last line of defense, you can use Content Security Policy (CSP) to reduce the severity of any XSS vulnerabilities that still occur.



# Common questions

**What is the difference between XSS and CSRF?** XSS involves causing a web site to return malicious JavaScript, while CSRF involves inducing a victim user to perform actions they do not intend to do.


**What is the difference between XSS and SQL injection?** XSS is a client-side vulnerability that targets other application users, while SQL injection is a server-side vulnerability that targets the application's database.