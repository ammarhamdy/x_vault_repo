# The Bourne Shell: /bin/sh


## Shell:
+ The shell is one of the most important parts of a Unix system.
+ A shell is a program that runs commands, like the ones that users enter into a terminal window. 
+ These commands can be other programs or built-in features of the shell. The shell also serves as a small programming environment.
+ Linux uses an enhanced version of the Bourne shell called bash.
+ The bash shell is the default shell on most Linux distributions, and /bin/sh is normally a link to bash on a Linux system.


## Standard Input and Standard Output:
+ Unix processes use I/O streams to read and write data. 
+ Processes read data from input streams and write data to output streams.
+ Streams are very flexible. 
+ For example, the source of an input stream can be a file, a device, a terminal window, or even the output stream from another process.


## Use cat command with no file:
+ When you don’t specify an input filename, cat reads from the standard input stream provided by the Linux kernel rather than a stream connected to a file.
+ In this case, the standard input is connected to the terminal where you run cat.


## Ctrl + D:
+ Pressing CTRL-D on an empty line stops the current standard input entry from the terminal with an `EOF` (end-of-file) message (and often terminates a program). 
+ Don’t confuse this with CTRL-C, which usually terminates a program regardless of its input or output.


## Standard output:
+ Standard output is similar Standard input. 
+ The kernel gives each process a standard output stream where it can write its output. 
+ The cat command always writes its output to the standard output.
+ When you ran cat in the terminal, the standard output was connected to that terminal, so that’s where you saw the output.
+ Standard input and output are often abbreviated as `stdin` and `stdout`.
+ Many commands operate as cat does; if you don’t specify an input file, the command reads from `stdin`. 
+ Output is a little different. Some programs (like cat) send output only to `stdout`, but others have the option to send output directly to files.
+ There is a third standard I/O stream, called standard error.


## Best features of standard streams:
+ One of the best features of standard streams is that you can easily manipulate them to read and write to places other than the terminal.



---
# Basic command


## Touch:
+ The `touch` command can create a file. 
+ If the target file already exists, touch doesn’t change the file, but it does update the file’s modification timestamp.


## Echo:
+ The echo command prints its arguments to the standard output.


## Navigating Directories:
+ When a path starts with / (such as `/usr/lib`), it’s a full or **absolute path**.
+ A path component identified by two dots (`..`) specifies the parent of a directory.
+ One dot (`.`) refers to the current directory.
+ A path not beginning with / is called a relative path.
+ Some programs abbreviate your home directory with the `~` symbol (a tilde).


## Cd command:
+ The `cd` command is a shell built-in. 
+ It wouldn’t work as a separate program because if it were to run as a sub-process, it could not (normally) change its parent’s current working directory.


## Shell Globbing (“Wildcards”):
+ The shell can match simple patterns to file and directory names, a process known as globbing (الخفقان).
+ The simplest of these is the glob character `*`, which tells the shell to match any number of arbitrary characters.
+ The substitution is called expansion because the shell substitutes(بدائل) all matching filenames for a simplified expression. 
+ Here are some ways to use * to expand filenames:
	+ `at*` expands to all filenames that start with at.
	+ `*at` expands to all filenames that end with at.
+ If no files match a glob, the bash shell performs no expansion, and the command runs with literal characters such as *.


## Question mark:
+ Another shell glob (الكرة الأرضية) character, the question mark (`?`) instructs the shell to match exactly one arbitrary character.
+ If you don’t want the shell to expand a glob in a command, enclose the glob in single quotes (`''`).


## grep command:
+ The grep command prints the lines from a file or input stream that match an expression.
+ For example, to print the lines in the `/etc/passwd` file that contain the text root, enter this:
```shell
>> grep root /etc/passwd
```
+ If you want to check every file in /etc that contains the word root, you could use this command:
```shell
>> grep root /etc/*
```


## Less command:
+ The less command is an enhanced version of an older program named more.
+ When running less, you’ll see the contents of the file one screen-full at a time. 
+ Press the `space-bar` to go forward in the file and press `b` (lowercase) to skip back one screen-ful. 
+ To quit, press `q`.


## Use less to search:
+ You can also search for text inside less. 
+ For example, to search forward for a word, you can type /word, and to search backward, you can use ?word. 
+ When you find a match, press n to continue searching.


## print working directory:
+ `pwd` program simply outputs the name of the current working directory.


## File command:
+ If you see a file and are unsure of its format, try using the file command to see if the system can guess it.


## Find and locate command:
+ Most systems also have a locate command for finding files. 
+ Rather than searching for a file in real time, locate searches an index that the system builds periodically. 
+ Searching with locate is much faster than find, but if the file you’re looking for is newer than the index, locate won’t find it.


---
# Changing Your Password and Shell


## Password command: 
+ Use the `passwd` command to change your password.
+ The best passwords tend to be long “nonsense” sentences that are easy to remember.


---
# Dot file


## Dot files and directories:
+ These are files and directories whose names begin with a dot (.). 
+ Common dot files are `.bashrc` and `.login`, and there are dot directories, too, such as .ssh.
+ Some programs don’t show them by default so that you won’t see a complete mess when listing the contents of your home directory.
+ `ls` doesn’t list dot files unless you use the -a option. 
+ Shell globs don’t match dot files unless you explicitly use a pattern such as `.*.`.


---
# Environment and Shell Variables


## Shell variables:
+ Shell variables are very useful for keeping track of values in scripts, and some shell variables control the way the shell behaves.
```shell
var=home
```
+ Don’t put any spaces around the = when assigning a variable.


## Environment variable:
+ An environment variable is like a shell variable, but it’s not specific to the shell. 
+ All processes on Unix systems have environment variable storage. 
+ The main difference between environment and shell variables is that the operating system passes all of your shell’s environment variables to programs that the shell runs, whereas shell variables cannot be accessed in the commands that you run.
+ You assign an environment variable with the shell’s `export` command.
```shell
STUFF=blah
export STUFF
```
+ Because child processes inherit environment variables from their parent, many programs read them for configuration and options.


## Path variable:
+ `PATH` is a special environment variable that contains the command path (or path for short), a list of system directories that the shell searches when trying to locate a command.
+ For example, when you run ls, the shell searches the directories listed in PATH for the ls program.
+ If programs with the same name appear in several directories in the path, the shell runs the first matching program.
+ If you run echo $PATH, you’ll see that the path components are separated by colons (:). For example:
```shell
>> echo $PATH                                                
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games
```
+ by using this command, you can add a directory `dir` to the beginning of the path so that the shell looks in `dir` before looking in any of the other PATH directories:
```
>> PATH=dir:$PATH
```
+ Or you can append a directory name to the end of the PATH variable, causing the shell to look in `dir` last:
```shell
>> PATH=$PATH:dir
```


---
# Command-Line Editing

## Keystrokes:
+ CTRL-B -> 	Move the cursor left
+ CTRL-F -> 	Move the cursor right
+ CTRL-P -> 	View the previous command (or move the cursor up)
+ CTRL-N -> 	View the next command (or move the cursor down)
+ CTRL-A -> 	Move the cursor to the beginning of the line
+ CTRL-E -> 	Move the cursor to the end of the line
+ CTRL-W -> 	Erase the preceding word
+ CTRL-U -> 	Erase from cursor to beginning of line
+ CTRL-K -> 	Erase from cursor to end of line
+ CTRL-Y -> 	Paste erased text (for example, from CTRL-U)



---
# Getting Online Help:
+ Linux systems come with a wealth of documentation.
+ For basic commands, the manual pages (or man pages) will tell you what you need to know.
+ When programs have many options, the manual page often lists the options in some systematic way (for example, in alphabetical order), but it won’t tell you what the important ones are.
+ To search for a manual page by keyword, use the -k option:
```shell
>> man -k keyword
```
+ This is helpful if you don’t quite know the name of the command that you want. For example, if you’re looking for a command to sort something, run:
```SHell
>> man -k sort

comm (1) - compare two sorted files line by line
qsort (3) - sorts an array
sort (1) - sort lines of text files
sortm (1) - sort messages
tsort (1) - perform topological sort
```
+ The output includes the manual page name, the manual section (see below), and a quick description of what the manual page contains.


## Manual page sections:
+ When someone refers to a manual page, they often put the section number in parentheses next to the name.
+ 1 ->	User commands
+ 2 ->	Kernel system calls
+ 3 ->	Higher-level Unix programming library documentation
+ 4 ->	Device interface and driver information
+ 5 ->	File descriptions (system configuration files)
+ 6 ->	Games
+ 7 ->	File formats, conventions, and encodings (ASCII, suffixes, and so on)
+ 8 ->	System commands and servers


## Select the section:
+ You can select a manual page by section. 
+ For example, to read the `/etc/passwd` file description, you can insert the section number before the page name like so:
```shell
>> man 5 passwd
```


## Information command:
+ Some time ago, the GNU Project decided that it didn’t like manual pages very much and switched to another format called info (or `texinfo`).


## Shell Input and Output:
+ To send the output of command to a file instead of the terminal, use the > redirection character:
```sh
>> command > file
```
+ The shell creates file if it does not already exist. 
+ If file exists, the shell erases (clobbers) the original file first.
+ You can append the output to the file instead of overwriting it with the >> redirection syntax:
```sh
>> command >> file
```


## Pip character:
+ To send the standard output of a command to the standard input of another command, use the pipe character (|).
```sh
>> head /proc/cpuinfo | tr a-z A-Z
```
+ You can send output through as many piped commands as you wish.



---
# Understanding Error Messages


## Standard Error:
+ Occasionally (أحياناً), you may redirect standard output but find that the program still prints something to the terminal. 
+ This is called standard error (`stderr`).
+ For example, this command produces an error:
```sh
>> ls /fffffffff > f
```
+ You can redirect the standard error if you like. 
+ For example, to send standard output to f and standard error to e, use the 2> syntax, like this:
```sh
>> ls /fffffffff > f 2> e
```
+ The number 2 specifies the stream ID that the shell modifies.


## Stream ID:
+ Stream ID 1 is standard output (the default), and 2 is standard error.
+ You can also send the standard error to the same place as stdout with the >& notation. 
+ For example, to send both standard output and standard error to the file named f, try this command:
```sh
>> ls /fffffffff > f 2>&1
```


## Standard Input Redirection:
+ To channel a file to a program’s standard input, use the < operator:
```sh
>> head < /proc/cpuinfo
```


## Anatomy of a Unix Error Message:
+ Most Unix programs generate and report the same basic error messages, but there can be subtle differences between the output of any two programs.
+ Here’s an example that you’ll certainly encounter in some form or other:
```sh
>> ls /dsafsda
ls: cannot access /dsafsda: No such file or directory
```
+ here are three components to this message:
	+ The program name, `ls`.
	+ The filename, `/dsafsda`.
	+ The error "No such file or directory" indicates the problem with the filename.


## Warning Message:
+ A warning usually means something is wrong but the program will try to continue running anyway. 
+ To fix a problem noted in a warning message, you may have to hunt down a process and kill it before doing anything else.


## Common Errors:
+ No such file or directory.
+ File exists.
+ Not a directory, Is a directory.
+ No space left on device.
+ Permission denied.
+ Operation not permitted.
+ Segmentation fault, Bus error.


----
# Listing and Manipulating Processes


## Listing and Manipulating Processes:
+ A process is a running program. 
+ Each process on the system has a numeric process ID (`PID`). 
+ For a quick listing of running processes, just run `ps` on the command line:
```sh
>> ps 
PID TTY STAT TIME COMMAND
  520 p0  S    0:00 -bash
  545  ?  S    3:59 /usr/X11R6/bin/ctwm -W
  548  ?  S    0:10 xclock -geometry -0-0
 2159 pd  SW   0:00 /usr/bin/vi lib/addresses
31956 p3  R    0:00 ps
```
+ The fields are as follows:
	+ `PID`.
	+ `TTY`.
	+ `STAT`.
	+ `TIME`.
	+ `COMMAND`.


### PID:
- The process ID.
- PIDs are unique for each process running on a system. 
- However, after a process terminates, the kernel can eventually reuse the PID for a new process.


### TTY:
+ The terminal device where the process is running.


### STAT:
+ The process status—that is, what the process is doing and where its memory resides. 
+ For example, `S` means sleeping and `R` means running. 
+ (See the ps(1) manual page for a description of all the symbols.)


#### Process state codes:
+ Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:
	+ `D`    uninterruptible sleep (usually IO)
	+ `I`    Idle kernel thread
	+ `R`    running or runnable (on run queue)
	+ `S`    interruptible sleep (waiting for an event to complete)
	+ `T`    stopped by job control signal
	+ `t`    stopped by debugger during the tracing
	+ `W`    paging (not valid since the 2.6.xx kernel)
	+ `X`    dead (should never be seen)
	+ `Z`    defunct ("zombie") process, terminated but not reaped by its parent.
+ For BSD formats and when the stat keyword is used, additional characters may be displayed:
	+ `<`    high-priority (not nice to other users)
	+ `N`    low-priority (nice to other users)
	+ `L`    has pages locked into memory (for real-time and custom IO)
	+ `s`    is a session leader
	+ `l`    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
	+ `+`    is in the foreground process group


### TIME:
+ The amount of CPU time in minutes and seconds that the process has used so far. 
+ In other words, the total amount of time that the process has spent running instructions on the processor.


### COMMAND:
+ This one might seem obvious as the command used to run the program, but be aware that a process can change this field from its original value. 
+ Furthermore, the shell can perform glob expansion, and this field will reflect the expanded command instead of what you enter at the prompt.


## `ps` Command Options:
+ You can specify options in three different styles—Unix, BSD, and GNU.
+ We use BSD style.
+ Here are some of the most useful option combinations:
	+ `ps x` Show all of your running processes.
	+ `ps ax` Show all processes on the system, not just the ones you own.
	+ `ps u` Include more detailed information on processes.
	+ `ps w` Show full command names, not just what fits on one line.


## Current process id:
+ To check on a specific process, add its `PID` to the argument list of the `ps` command. 
+ For example, to inspect the current shell process, you can use `ps u $$` (`$$` is a shell variable that evaluates to the current shell’s `PID`).


## Process Termination:
+ To terminate a process, you send it a signal—a message to a process from the kernel—with the kill command.
```sh
>> kill pid
```
+ There are many types of signals. 
+ The default (used above) is TERM, or terminate. 
+ You can send different signals by adding an extra option to kill. 
+ For example, to freeze a process instead of terminating it, use the STOP signal:
+ A stopped process is still in memory, ready to pick up where it left off.
+ Use the CONT signal to continue running the process again:
```sh
>> kill -STOP pid
>> kill -CONT pid
```


### Ctr + c = TERM:
+ Using CTRL-C to terminate a process that is running in the current terminal is the same as using kill to end the process with the INT (interrupt) signal.


## Kill signal:
+ The kernel gives most processes a chance to clean up after themselves upon receiving signals (with the signal handler mechanism). 
+ However, some processes may choose a nonterminating action in response to a signal, get wedged in the act of trying to handle it, or simply ignore it, so you might find a process still running after you try to terminate it.
+ If this happens and you really need to kill a process, the most brutal way to terminate it is with the KILL signal. 
+ Unlike other signals, KILL cannot be ignored; in fact, the operating system doesn’t even give the process a chance.


## Signal numbers:
+ The kernel uses numbers to denote the different signals; you can use kill this way if you know the number of the signal that you want to send. 
+ Run kill -l to get a mapping of signal numbers to names.


## Job Control:
+ Shells support job control, a way to send `TSTP` (similar to STOP) and CONT signals to programs by using various keystrokes and commands. 
+ This allows you to suspend and switch between programs you’re using. 
+ For example, you can send a `TSTP` signal with CTRL-Z and then start the process again by entering `fg` (bring to foreground) or bg` `move to background.


## Background Processes:
- You can detach (فصل) a process from the shell and put it in the “background” with the ampersand (&); this gives you the prompt back.
```sh
>> gunzip file.gz &
```
+ The shell should respond by printing the `PID` of the new background process, and the prompt should return immediately so that you can continue working.
+ If a program tries to read something from the standard input when it’s in the background, it can freeze (try fg to bring it back) or terminate.
+ Also, if the program writes to the standard output or standard error, the output can appear in the terminal window with no regard for anything else running there, meaning that you can get unexpected output when you’re working on something else.
+ If spurious output from background processes gets in your way, learn how to redraw the content of your terminal window.
+ The bash shell and most full-screen interactive programs support CTRL-L to redraw the entire screen.
+ If a program is reading from the standard input, CTRL-R usually redraws the current line, but pressing the wrong sequence at the wrong time can leave you in an even worse situation than before.



---
# File Modes and Permissions


## The pieces of a file mode:
+ ![[Pasted image 20230614172306.png]]
+ The first character of the mode is the file type:
	+ A dash (-) in this position, as in the example, denotes a regular file, meaning that there’s nothing special about the file; it’s just binary or text data.
+ Each permission set can contain four basic representations:
	+ `r` means that the file is readable.
	+ `w` means that the file is writable.
	+ `x` means that the file is executable (you can run it as a program).
	+ `-` means “nothing” (more specifically, the permission for that slot in the set has not been granted).
+ The user permissions (the first set) pertain to the user who owns the file.
+ The second set, group permissions, are for the file’s group:
	+ Any user in that group can take advantage of these permissions.
	+ Use the groups command to see what group you’re in
+ Everyone else on the system has access according to the third set, the other permissions, which are sometimes called world permissions.


## Executable files:
+ Some executable files have an `s` in the user permissions listing instead of an `x`. 
+ This indicates that the executable is `setuid`, meaning that when you execute the program, it runs as though the file owner is the user instead of you. 
+ Many programs use this `setuid` bit to run as root in order to get the privileges they need to change system files. 
+ One example is the `passwd` program, which needs to change the `/etc/passwd `file.


## Modifying Permissions:
+ To change permissions on a file or directory, use the chmod command. 
+ First, pick the set of permissions that you want to change, and then pick the bit to change. 
+ For example, to add group (g) and world (o, for “other”) read (r) permissions to file, you could run these two commands:
```sh
>> chmod g+r file
>> chmod go+r file
```
+ To remove these permissions, use `go-r` instead of `go+r`.


## Causion:
+ Obviously, you shouldn’t make files world-writable because doing so enables anyone on your system to change them. 
+ But would this also allow anyone connected to the internet to change them? Probably not, unless your system has a network security hole.


## Most common permission modes:
+ 644 ->	user: read/write; group, other: read	files
+ 600 ->	user: read/write; group, other: none	files
+ 755 ->	user: read/write/execute; group, other: read/execute	directories, programs
+ 700 ->	user: read/write/execute; group, other: none	directories, programs
+ 711 ->	user: read/write/execute; group, other: execute	directories


## Directories permissions:
+ Directories also have permissions. 
+ You can list the contents of a directory if it’s readable, but you can only access a file in a directory if the directory is executable. 
+ You need both in most cases; one common mistake people make when setting the permissions of directories is to accidentally remove the execute permission when using absolute modes.


## `umask` command:
+ you can specify a set of default permissions with the `umask` shell command, which applies a predefined set of permissions to any new file you create. 
+ In general, use `umask` 022 if you want everyone to be able to see all of the files and directories that you create, and use `umask` 077 if you don’t.


## Working with Symbolic Links:
+ A symbolic link is a file that points to another file or a directory, effectively creating an alias (like a shortcut in Windows). 
+ Symbolic links offer quick access to obscure directory paths.
+ Notice the l as the file type in the file mode:
```sh
lrwxrwxrwx 1 ruser users  11 Feb 27 13:52 somedir -> /home/origdir
```
 + If you try to access `somedir` in this directory, the system gives you `/home/origdir` instead.
 + Symbolic links are simply filenames that point to other names.


### Create symbolic link:
+ To create a symbolic link from target to `linkname`, use `ln -s` as follows:
```sh
>> ln -s target linkname
```
+ The -s flag specifies a symbolic link.
+ Without `-s` option, `ln` creates a hard link, giving an additional real filename to a single file. 
+ The new filename has the status of the old one; it points (links) directly to the file data instead of to another filename as a symbolic link does.


---
# Archiving and Compressing Files


## Gun zip:
+ The program `gzip` (GNU Zip) is one of the current standard Unix compression programs.
+ A file that ends with `.gz` is a GNU Zip archive. 
+ Use `gunzip file.gz` to un-compress `<file>.gz` and remove the suffix; to compress the file again, use `gzip` file.


## tar:
+ Unlike the ZIP programs for other operating systems, `gzip` does not create archives of files; that is, it doesn’t pack multiple files and directories into a single file. 
+ To create an archive, use tar instead:
```sh
>> tar cvf archive.tar file1 file2 ...
```
+ The `c` flag activates create mode.
+ The `v` flag activates verbose diagnostic output, causing tar to print the names of the files and directories in the archive when it encounters them. 
	+ Adding another v causes tar to print details such as file size and permissions. 
	+ If you don’t want tar to tell you what it’s doing, omit the v flag.
+ The `f` flag denotes the file option.
+ To use standard input or output, set the filename to a dash (-).


### Unpacking .tar Files:
+ To unpack a .tar file with tar use the x flag:
```sh
>> tar xvf archive.tar
```
+ the x flag puts tar into extract (unpack) mode. 
+ You can extract individual parts of the archive by entering the names of the parts at the end of the command line, but you must know their exact names.


### Using Table-of-Contents Mode:
+ Before unpacking, it’s usually a good idea to check the contents of a .tar file with the table-of-contents mode by using the t flag instead of the x flag. 
+ This mode verifies the archive’s basic integrity and prints the names of all files inside


### Override permissions:
+ When unpacking, consider using the p option to preserve permissions. 
+ Use this in extract mode to override your `umask` and get the exact permissions specified in the archive.
+ The p option is the default when you’re working as the superuser.


## Compressed Archives (`.tar.gz`):
+ To unpack a compressed archive, work from the right side to the left; get rid of the `.gz` first and then worry about the `.tar`.
```sh
>> gunzip file.tar.gz
>> tar xvf file.tar
```
+ running `gunzip` to decompress and then tar to verify and unpack.
+ To create a compressed archive, do the reverse: 
	+ Run `tar` first and `gzip` second.


## `zcat` command:
+ A better way is to combine archival and compression functions with a pipeline:
+ For example, this command pipeline unpacks `<file>.tar.gz`:
```sh
>> zcat file.tar.gz | tar xvf -
```
+ The `zcat` command is the same as `gunzip -dc`:
	+ The `-d` option decompresses.
	+ The `-c` option sends the result to standard output (in this case, to the tar command).
+ Because it’s so common to use `zcat`, the version of tar that comes with Linux has a shortcut. 
+ You can use `z` as an option to automatically invoke `gzip` on the archive; this works both for extracting an archive.
+ For example, use the following to verify a compressed archive:
```sh
tar ztvf file.tar.gz
```


## `tgz` suffix:
+ A `.tgz` file is the same as a `.tar.gz` file.
+ The suffix is meant to fit into FAT (MS-DOS-based) file systems.


## Other Compression Utilities:
+ Two more compression programs are `xz` and `bzip2`, whose compressed files end with `.xz` and `.bz2`, respectively. 
+ While marginally slower than gzip, these often compact (المدمج) text files a little more.
+ The decompressing programs to use are `unxz` and `bunzip2`.
+ Most Linux distributions come with `zip` and `unzip` programs that are compatible with the ZIP archives on Windows systems.
+ They work on the usual `.zip` files as well as self-extracting archives ending in `.exe`. 
+ But if you encounter a file that ends in `.Z`, you have found a relic created by the `compress` program, which was once the Unix standard. 
+ The gun zip program can unpack these files, but `gzip` won’t create them.


---
# Linux Directory Hierarchy Essentials


## Filesystem Hierarchy Standard (FHS):
+ [See](https://refspecs.linuxfoundation.org/fhs.shtml).
+ ![[Pasted image 20230614232612.png]]


### /bin directory:
+ Contains ready-to-run programs (also known as executables), including most of the basic Unix commands such as ls and `cp`.
+ Most of the programs in `/bin` are in binary format, having been created by a C compiler, but some are shell scripts in modern systems.


### /etc directory:
+ This core system configuration directory (pronounced EHT-see) contains the user password, boot, device, networking, and other setup files.


### /dev directory:
+ Contains device files.


### /home directory:
+ Holds home (personal) directories for regular users.
+ Most Unix installations conform to this standard.


### /lib directory:
+ An abbreviation (اختصار) for library, this directory holds library files containing code that executables can use.
+ There are two types of libraries: 
	+ Static.
	+ Shared.
+ The /lib directory should contain only shared libraries, but other lib directories, such as `/usr/lib`, contain both varieties (أصناف) as well as other auxiliary (مساعد) files.


### /proc directory:
+ Provides system statistics through a browsable directory-and-file interface. 
+ Much of the /proc subdirectory structure on Linux is unique, but many other Unix variants have similar features.
+ The /proc directory contains information about currently running processes as well as some kernel parameters.


### /run directory:
+ Contains runtime data specific to the system, including certain process IDs, socket files, status records, and, in many cases, system logging. 
+ This is a relatively recent addition to the root directory; in older systems, you can find it in /var/run. On newer systems, /var/run is a symbolic link to /run.


### /sys directory:
+ This directory is similar to /proc in that it provides a device and system interface.


### /sbin directory:
+ The place for system executable_s.
+ Programs in /sbin directories relate to system management, so regular users usually do not have /sbin components in their command paths. 
+ Many of the utilities found here don’t work if not run as root.


### /tmp directory:
+ A storage area for smaller, temporary files that you don’t care much about. 
+ Any user may read to and write from /tmp, but the user may not have permission to access another user’s files there.
+ Many programs use this directory as a workspace. 
+ If something is extremely important, don’t put it in /tmp because most distributions clear /tmp when the machine boots and some even remove its old files periodically. 
+ Also, don’t let /tmp fill up with garbage because its space is usually shared with something critical (the rest of /, for example).


### /usr directory:
+ Although pronounced “user,” this subdirectory has no user files. 
+ Instead, it contains a large directory hierarchy, including the bulk of the Linux system. 
+ Many of the directory names in /usr are the same as those in the root directory (like /usr/bin and /usr/lib), and they hold the same type of files.
+ The reason that the root directory does not contain the complete system is primarily historic—in the past, it was to keep space requirements low for the root.


### /var directory:
+ The variable subdirectory, where programs record information that can change over the course of time. 
+ System logging, user tracking, caches, and other files that system programs create and manage are here. 
+ You’ll notice a /var/tmp directory here, but the system doesn’t wipe it on boot.


### /boot directory:
+ Contains kernel boot loader files.
+ These files pertain only to the very first stage of the Linux startup procedure, so you won’t find information about how Linux starts up its services in this directory.


### /media directory:
+ A base attachment point for removable media such as flash drives that is found in many distributions.


### /opt directory:
+ This may contain additional third-party software.
+ Many systems don’t use /opt.


## The /usr Directory:
+ /usr is where most of the user-space programs and data reside. 
+ In addition to `/usr/bin`, /`usr/sbin`, and `/usr/lib`, `/usr` contains the following:
	+ /include
	+ /local
	+ /man
	+ /share


### /include:
+ Holds header files used by the C compiler.


### /local:
+ Is where administrators can install their own software.
+ Its structure should look like that of `/` and `/usr`.


### /man:
+ Contains manual pages.


### /share:
+ Contains files that should work on other kinds of Unix machines with no loss of functionality.
+ These are usually auxiliary (إضافي) data files that programs and libraries read as necessary.
+ In the past, networks of machines would share this directory from a file server, but today a share directory used in this manner is rare because there are no realistic space restraints (القيود) for these kinds of files on contemporary (معاصر) systems. 
+ Instead, on Linux distributions, you’ll find /man, /info, and many other sub_directories here because it is an easily understood convention.


## Kernel Location:
+ On Linux systems, the kernel is normally a binary file `/vmlinuz` or `/boot/vmlinuz`. 
+ A boot loader loads this file into memory and sets it in motion when the system boots.
+ Once the boot loader starts the kernel, the main kernel file is no longer used by the running system. 
+ However, you’ll find many modules that the kernel loads and unloads on demand during the course of normal system operation. 
+ Called loadable kernel modules, they are located under `/lib/modules`.



---
# Running Commands as the Superuser


## `sudo`:
+ Most distributions use a package called `sudo` to allow administrators to run commands as root when they are logged in as themselves.


## /etc/sudoers:
+ Of course, the system doesn’t let just any user run commands as the superuser; you must configure the privileged users in your `/etc/sudoers` file.
+ The `sudo` package has many options (that you’ll probably never use), which makes the syntax in `/etc/sudoers` somewhat complicated. 
+ For example, this file gives `user1` and user2` `the power to run any command as root without having to enter a password:
```sh
User_Alias ADMINS = user1, user2

ADMINS ALL = NOPASSWD: ALL

root ALL=(ALL) ALL
```
+ The first line defines an ADMINS user alias with the two users, and the second line grants the privileges.
+ The `ALL = NOPASSWD: ALL` part means that the users in the ADMINS alias can use sudo to execute commands as root:
	+ The first ALL means “any host.”
	+ The second `ALL` means “any command.”
+ The `root ALL=(ALL) ALL` simply means that the superuser may also use `sudo` to run any command on any host:
	+ The extra (`ALL`) means that the superuser may also run commands as any other user.
+ You can extend this privilege to the `ADMINS` users by adding (`ALL`) to the second /etc/sudoers line, as shown here:
```sh
ADMINS ALL = (ALL) NOPASSWD: ALL
```


## sudo Logs:
+ You can find the sudo logs on most systems with this command:
```sh
>> journalctl SYSLOG_IDENTIFIER=sudo
```
+ On older systems, you’ll need to look for a `logfile` in /var/log, such as `/var/log/auth.log`.