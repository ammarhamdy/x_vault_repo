# Device Files

---
## Device I/O interfaces:
+ It’s easy to manipulate most devices on a Unix system because the kernel presents many of the device I/O interfaces to user processes as files. 
+ These device files are sometimes called device nodes.
+ However, there is a limit to what you can do with a file interface, so not all devices or device capabilities are accessible with standard file I/O.
---


## Home of devices:
+ Device files are in the `/dev` directory.
```shell
>>> ls -l /dev   
total 0
crw-r--r--  1 root root     10,   235 Jul 21 10:08 autofs
drwxr-xr-x  2 root root           420 Jul 21 10:08 block
drwxr-xr-x  2 root root            60 Jul 21 10:08 bsg
...
```
+ Note the first character of each line If this character is b, c, p, or s, the file is a device.
+ These letters stand for block, character, pipe, and socket, respectively.


### Block device:
+ Programs access data from a block device in fixed chunks.
```shell
brw-rw----   1 root disk 8, 1 Sep  6 08:37 sda1
```
+ The `sda1` in the preceding example is a disk device, a type of block device.
+ Disks can be easily split up into blocks of data.
+ Because a block device’s total size is fixed and easy to index, processes have quick random access to any block in the device with the help of the kernel.


### Major and minor:
```shell
ls -l /dev | grep sda
brw-rw----  1 root disk      8,     0 Jul 21 10:08 sda
brw-rw----  1 root disk      8,     1 Jul 21 10:08 sda1
brw-rw----  1 root disk      8,     2 Jul 21 10:08 sda2
brw-rw----  1 root disk      8,     3 Jul 21 10:08 sda3
```
+ In file listings from ls -l of block and character devices, the numbers before the dates are the major and minor device numbers that the kernel uses to identify the device. 
+ Similar devices usually have the same major number, such as `sda3` and `sdb1` (both of which are hard disk partitions).


### Character device:
+ Character devices work with data streams.
+ You can only read characters from or write characters to character devices.
+ Printers directly attached to your computer are represented by character devices.
+ It’s important to note that during character device interaction, the kernel cannot back up and reexamine (إعادة الفحص) the data stream after it has passed data to a device or process.


### Pipe device:
+ Named pipes are like character devices, with another process at the other end of the I/O stream instead of a kernel driver.


### Socket device:
+ Sockets are special-purpose interfaces that are frequently used for inter-process communication.
+ Socket files represent Unix domain sockets.



---
# [Major and Minor device numbers](https://unix.stackexchange.com/questions/73988/linux-major-and-minor-device-numbers)


+ All devices have a `major, minor` number pair. 


## Major (رئيسي) number:
+ The major device number identifies the driver (e.g. IDE disk drive, floppy disk, parallel port, serial, port, ...)
+ The major number is a larger, more generic category (e.g. hard disks, input/output devices etc...)


## Minor(صغير) number:
+ The minor number is more specific (i.e. tells what bus the device is connected to).
+ The minor number identifies the specific device (i.e., the first floppy would have minor 0, the second would be 1, ...).


### For more:
+ [linux docs devices list](http://mirrors.mit.edu/kernel/linux/docs/lanana/device-list/devices-2.6.txt)
+ ![[linux.docs.lanana.devices_list.devices-2.6.txt]]

---
# The `sysfs` Device Path:


## Limitation of `/dev`:
+ The traditional Unix `/dev` directory is a convenient (مريح) way for user processes to reference and interface with devices supported by the kernel, but it’s also a very simplistic (تبسيطي) scheme.
+ he name of the device in `/dev` tells you a little about the device, but usually not enough to be helpful.
+ Another problem is that the kernel assigns devices in the order in which they are found, so a device may have a different name between reboots.


## `sysfs`:
+ To provide a uniform view for attached devices based on their actual hardware attributes, the Linux kernel offers the `sysfs` interface through a system of files and directories.
+ The base path for devices is `/sys/devices`. 
+ For example, the SATA hard disk at `/dev/sda` might have the following path in `sysfs`:
```
/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda
```
+ [wiki sysfs](https://en.wikipedia.org/wiki/Sysfs)


## List /sys/devices:
```shell
>> ls -l /sys/devices
total 0
drwxr-xr-x  3 root root 0 Jul 21 10:08 breakpoint
drwxr-xr-x  6 root root 0 Jul 21 10:08 cpu
drwxr-xr-x  5 root root 0 Jul 21 10:08 cstate_core
drwxr-xr-x  5 root root 0 Jul 21 10:08 cstate_pkg
drwxr-xr-x  5 root root 0 Jul 21 10:08 i915
drwxr-xr-x  3 root root 0 Jul 21 10:08 intel_bts
drwxr-xr-x  5 root root 0 Jul 21 10:08 intel_pt
drwxr-xr-x  4 root root 0 Jul 21 10:08 kprobe
drwxr-xr-x  9 root root 0 Jul 21 10:08 LNXSYSTM:00
drwxr-xr-x  5 root root 0 Jul 21 10:08 msr
drwxr-xr-x 27 root root 0 Jul 21 10:08 pci0000:00
...
```


### Inside sda:
+ look to `sda` directory:
```shell
>>> ls "sys/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda" | nl
     1  alignment_offset
     2  bdi
     3  capability
     4  dev
     5  device
     6  discard_alignment
     7  diskseq
     8  events
     9  events_async
    10  events_poll_msecs
    11  ext_range
    12  hidden
    13  holders
    14  inflight
    15  integrity
    16  mq
    17  power
    18  queue
    19  range
    20  removable
    21  ro
    22  sda1
    23  sda2
    24  sda3
    25  size
    26  slaves
    27  stat
    28  subsystem
    29  trace
    30  uevent
>>> ls "sys/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda/sda1" | nl
     1  alignment_offset
     2  dev
     3  discard_alignment
     4  holders
     5  inflight
     6  partition
     7  power
     8  ro
     9  size
    10  start
    11  stat
    12  subsystem
    13  trace
    14  uevent
```
+ Running `cat dev` in this directory displays the numbers `8:1`, which happen to be the **major** and **minor** device numbers of `/dev/sda`.
```shell
>>> cat "/sys/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda/sda1/dev"   
8:1

```


## `/dev` vs `/sys/devices`:
+ The `/dev` file enables user processes to use the device, whereas the `/sys/devices` path is used to view information and manage the device.
+ The files and sub-directories in:
```
/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda
```
+ Are meant to be read primarily by programs rather than humans, but you can get an idea of what they contain and represent by looking at an example such as the `/dev` file.


## Short cut on `/sys`:
+ There are a few shortcuts in the `/sys` directory. 
+ For example, `/sys/block` should contain all of the block devices available on a system.
 + However, those are just symbolic links; you’d run `ls -l /sys/block` to reveal the true `sysfs` paths.


## `udevadm` command:
+ It can be difficult to find the `sysfs` location of a device in `/dev`.
+ Use the `udevadm` command as follows to show the path and several other interesting attributes:
```shell
>>> udevadm info --query=all --name=/dev/sda
P: /devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda
M: sda
U: block
T: disk
D: b 8:0
N: sda
L: 0
S: disk/by-diskseq/2
S: disk/by-id/ata-SAMSUNG_MZ7PD128HCFV-000H1_S1MBNSAFB65531
S: disk/by-path/pci-0000:00:0e.0-pci-10000:e0:17.0-ata-2
S: disk/by-id/wwn-0x5002538500000000
S: disk/by-path/pci-0000:00:0e.0-pci-10000:e0:17.0-ata-2.0
Q: 2
E: DEVPATH=/devices/pci0000:00/0000:00:0e.0/pci10000:e0/10000:e0:17.0/ata2/host1/target1:0:0/1:0:0:0/block/sda
E: DEVNAME=/dev/sda
E: DEVTYPE=disk
E: DISKSEQ=2
E: MAJOR=8
E: MINOR=0
E: SUBSYSTEM=block
...
```



---
# dd and Devices


## `dd` program:
+ The program `dd` is extremely useful when you are working with block and character devices. 
+ Its sole (منفرد) function is to read from an input file or stream and write to an output file or stream, possibly doing some encoding conversion on the way. 
+ One particularly useful `dd` feature with respect to block devices is that you can process a chunk of data in the middle of a file, ignoring what comes before or after.


## Use `dd` command:
+ `dd` copies data in blocks of a fixed size.
```shell
>>> dd if=/dev/zero of=new_file bs=1024 count=1
```
+ The preceding example copies a single 1,024-byte block from `/dev/zero `(a continuous stream of zero bytes) to `new_file`.


### `dd` command style:
+ As you can see, the dd option format differs from the option formats of most other Unix commands; it’s based on an old IBM Job Control Language (JCL) style.
+ Rather than use the dash (-) character to signal an option, you name an option and set its value with the equal (=) sign.


### These are the important dd options:
+ `if=file` The input file: 
	+ The default is the standard input.
+ `of=file` The output file:
	+ The default is the standard output.
+ `bs=size` The block size: 
	+ `dd` reads and writes this many bytes of data at a time. 
	+ To abbreviate (اختصر) large chunks of data, you can use b and k to signify 512 and 1,024 bytes, respectively.
	+ Therefore, the preceding example could read `bs=1k` instead of `bs=1024`.
+ `ibs=size`, `obs=size` The input and output block sizes:
	+ If you can use the same block size for both input and output, use the `bs` option; if not, use `ibs` and `obs` for input and output, respectively.
+ `count=num` The total number of blocks to copy:
	+ When working with a huge file—or with a device that supplies an endless stream of data, such as `/dev/zero`—you want `dd` to stop at a fixed point; otherwise, you could waste a lot of disk space, CPU time, or both.
	+ Use count with the skip parameter to copy a small piece from a large file or device.
+ `skip=num` :
	+ Skip past the first `num` blocks in the input file or stream, and do not copy them to the output.



---
# Device Name Summary


## Device Name Summary:
+ It can sometimes be difficult to find the name of a device (for example, when partitioning a disk). 


## Ways to find out the device name:
+ Query `udevd` using `udevadm` [[#`udevadm` command]].
+ Look for the device in the `/sys` directory.
+ Guess the name from the output of the `journalctl -k` command (which prints the kernel messages) or the kernel system log This output might contain a description of the devices on your system.
+ For a disk device that is already visible to the system, you can check the output of the `mount` command.
+ Run `cat /proc/devices` to see the block and character devices for which your system currently has drivers; Each line consists of a number and name; The number is the major number of the device as described [[#Major and minor]]


## Explanation of disk naming:
+ The naming convention requires a little explanation. 
+ The `sd` portion of the name stands for SCSI (small computer system interface) disk.
+ Small Computer System Interface (SCSI) was originally developed as a hardware and protocol standard for communication between devices such as disks and other peripherals (ملحقات).
+ Although traditional SCSI hardware isn’t used in most modern machines, the SCSI protocol is everywhere due to its adaptability.
+ For example, USB storage devices use it to communicate.
+ The story on SATA (Serial ATA, a common storage bus on PCs) disks is a little more complicated, but the Linux kernel still uses SCSI commands at a certain point when talking to them.


## List SCSI:
+ To list the SCSI devices on your system, use a utility that walks the device paths provided by `sysfs`. 
+ One of the most succinct tools is `lsscsi`. 
+ Here’s what you can expect when you run it:
```shell
>>> lsscsi
[1:0:0:0]    disk    ATA      SAMSUNG MZ7PD128 1H0Q  /dev/sda 
[N:0:1:1]    disk    INTEL SSDPEKNU512GZ__1                     /dev/nvme0n1
```


### Explain the output:
```shell
>>> lsscsi
[1:0:0:0]    disk    ATA      SAMSUNG MZ7PD128 1H0Q  /dev/sda 
# (1) [1:0:0:0]
# (2) disk
# (3:) ATA      SAMSUNG MZ7PD128 1H0Q  /dev/sda 
```
+ The first column 1 identifies the address of the device on the system, the second 2 describes what kind of device it is, and the last 3 indicates where to find the device file.
+ Everything else is vendor information.


## Hard Disks (`/dev/sd*`):
+ Most hard disks attached to current Linux systems correspond to device names with an `sd` prefix, such as `/dev/sda`, `/dev/sdb`, and so on.
+ These devices represent entire disks; the kernel makes separate device files, such as `/dev/sda1` and `/dev/sda2`, for the partitions on a disk.


## Virtual Disks (`/dev/xvd*`, `/dev/vd*`):
+ Some disk devices are optimized for virtual machines such as AWS instances and `VirtualBox`.
+ The `Xen` virtualization system uses the `/dev/xvd` prefix, and `/dev/vd` is a similar type.


## Non-Volatile Memory Devices (`/dev/nvme*`):
+ Non-Volatile (غير متطاير).
+ Some systems now use the Non-Volatile Memory Express (`NVMe`) interface to talk to some kinds of solid-state storage.
+ In Linux, these devices show up at `/dev/nvme*`. 
+ You can use the `nvme` list command to get a listing of these devices on your system.


## Device Mapper: (`/dev/dm-*`, `/dev/mapper/*`):
+ A level up from disks and other direct block storage on some systems is the `LVM`, which uses a kernel system called the device mapper.
+ If you see block devices starting with `/dev/dm-` and symbolic links in `/dev/mapper`, your system probably uses it.


## CD and DVD Drives (`/dev/sr*`):
+ Linux recognizes most optical storage drives as the SCSI devices `/dev/sr0`, `/dev/sr1`, and so on.
+ However, if the drive uses an older interface, it might show up as a PATA device. 
+ The `/dev/sr*` devices are read only, and they are used only for reading from discs.
+ For the write and rewrite capabilities of optical devices, you’ll use the “generic” SCSI devices such as `/dev/sg0`.


## PATA Hard Disks (`/dev/hd*`):
+ PATA (Parallel ATA) is an older type of storage bus.
+ The Linux block devices `/dev/hda`, `/dev/hdb`, `/dev/hdc`, and `/dev/hdd` are common on older versions of the Linux kernel and with older hardware. 
+ These are fixed assignments based on the device pairs on interfaces 0 and 1.
+ At times, you might find a SATA drive recognized as one of these disks. 
+ This means that the SATA drive is running in a compatibility mode, which hinders performance. 
+ Check your BIOS settings to see if you can switch the SATA controller to its native mode.

## Terminals (`/dev/tty*`, `/dev/pts/*`, and `/dev/tty`):
+ Terminals are devices for moving characters between a user process and an I/O device, usually for text output to a terminal screen. 
+ The terminal device interface goes back a long way, to the days when terminals were typewriter-based devices and many were attached to a single machine.


### Our terminal not real terminal:
+ Most terminals are pseudoterminal devices, emulated terminals that understand the I/O features of real terminals. 
+ Rather than talk to a real piece of hardware, the kernel presents the I/O interface to a piece of software, such as the shell terminal window that you probably type most of your commands into.
+ Two common terminal devices are `/dev/tty1` (the first virtual console) and `/dev/pts/0` (the first pseudoterminal device).
+ The `/dev/pts` directory itself is a dedicated filesystem.
+ The `/dev/tty` device is the controlling terminal of the current process. 
+ If a program is currently reading from and writing to a terminal, this device is a synonym (مرادف) for that terminal.
+ A process does not need to be attached to a terminal.


### Display Modes and Virtual Consoles:
+ Linux has two primary display modes: text mode and a graphical mode.
+ Although Linux systems traditionally booted in text mode, most distributions now use kernel parameters and interim graphical display mechanisms (bootsplashes such as plymouth) to completely hide text mode as the system is booting. 
+ In such cases, the system switches over to full graphics mode near the end of the boot process.

#### Switch between virtual console:
+ Linux supports virtual consoles to multiplex the display.
+ Each virtual console may run in graphics or text mode. 
+ When in text mode, you can switch between consoles with an ALT–function key combination—for example, `ALT-F1` takes you to `/dev/tty1`, `ALT-F2` goes to `/dev/tty2`, and so on. 
+ Many of these virtual consoles may be occupied by a getty process running a login prompt.


#### Virtual console used in graphics mode:
+ A virtual console used in graphics mode is slightly different.
+ Rather than getting a virtual console assignment from the init configuration, a graphical environment takes over a free virtual console unless directed to use a specific one.
+ For example, if you have getty processes running on `tty1` and `tty2`, a new graphical environment takes over `tty3`. 
+ In addition, once in graphics mode, you must normally press a CTRL-ALT–function key combination to switch to another virtual console instead of the simpler ALT–function key combination.
+ The upshot of all of this is that if you want to see your text console after your system boots, press `CTRL-ALT-F1`.
+ To return to the graphical environment, press `ALT-F2`, `ALT-F3`, and so on, until you get to the graphical environment.


##### `chvt` command:
+ If you run into trouble switching consoles due to a malfunctioning input mechanism or some other circumstance, you can try to force the system to change consoles with the `chvt` command.
+ For example, to switch to `tty1`, run the following as root:
> `chvt 1` 



## Serial Ports(`/dev/ttyS*`, `/dev/ttyUSB*`,`/dev/ttyACM*`):
+ Older RS-232 type and similar serial ports are represented as true terminal devices. 
+ You can’t do much on the command line with serial port devices because there are too many settings to worry about, such as baud rate and flow control, but you can use the screen command to connect to a terminal by adding the device path as an argument. 
+ You may need read and write permission to the device; sometimes you can do this by adding yourself to a particular group such as `dialout`.


### Port names:
+ The port known as `COM1` on Windows is `/dev/ttyS0`; `COM2` is `/dev/ttyS1`; and so on.
+ Plug-in USB serial adapters show up with USB and `ACM` with the names `/dev/ttyUSB0`, `/dev/ttyACM0`, `/dev/ttyUSB1`, `/dev/ttyACM1`, and so on.


### Micro controller application:
+ Some of the most interesting applications involving serial ports are `microcontroller-based` boards that you can plug into your Linux system for development and testing.
+ For example, you can access the console and read-eval-print loop of `CircuitPython` boards through a USB serial interface. 
+ All you need to do is plug one in, look for the device (it’s usually `/dev/ttyACM0`), and connect to it with screen.


## Parallel Ports: `/dev/lp0` and `/dev/lp1`
+ Representing an interface type that has largely been replaced by USB and networks, the unidirectional parallel port devices `/dev/lp0` and `/dev/lp1` correspond to `LPT1`: and `LPT2`: in Windows.
+ You can send files (such as a file to be printed) directly to a parallel port with the cat command, but you might need to give the printer an extra form feed or reset afterward. 
+ A print server such as CUPS is much better at handling interaction with a printer.
+ The bidirectional parallel ports are `/dev/parport0` and `/dev/parport1`.


## Audio Devices: `/dev/snd/*`, `/dev/dsp`, `/dev/audio`, and More
+ Linux has two sets of audio devices. 
+ There are separate devices for the ==Advanced Linux Sound Architecture== (`ALSA`) system interface and the older ==Open Sound System== (`OSS`).
+ The `ALSA` devices are in the `/dev/snd` directory, but it’s difficult to work with them directly.
+ Linux systems that use `ALSA` support `OSS` backward-compatible devices if the `OSS` kernel support is currently loaded.
+ Some rudimentary operations are possible with the `OSS dsp` and audio devices. 
+ For example, the computer plays any `WAV` file that you send to `/dev/dsp`.
+ However, the hardware may not do what you expect due to frequency mismatches.
+ Furthermore, on most systems, the device is often busy as soon as you log in.


## Device File Creation:
+ On any reasonably recent Linux system, you do not create your own device files; they’re created by `devtmpfs` and `udev`.
+ However, it is instructive to see how to do so, and on a rare occasion, you might need to create a named pipe or a socket file.
+ The `mknod` command creates one device.
+ You must know the device name as well as its major and minor numbers. 
+ For example, creating `/dev/sda1` is a matter of using the following command:
```
# mknod /dev/sda1 b 8 1
```
+ The `b 8 1 `specifies a block device with a major number `8` and a minor number `1`.
+ For character or named pipe devices, use `c` or `p` instead of `b`.


---
# 3.5 udev


+ The Linux kernel can send notifications to a user-space process called `udevd` upon detecting a new device on the system (for example, when someone attaches a USB flash drive).
+ This `udevd` process could examine the new device’s characteristics, create a device file, and then perform any device initialization. 
+ Unfortunately, there is a problem with this approach—device files are necessary early in the boot procedure, so `udevd` must also start early. 
+ But to create device files, `udevd` cannot depend on any devices that it is supposed to create, and it needs to perform its initial startup very quickly so that the rest of the system doesn’t get held up waiting for `udevd` to start.


## 3.5.1 `devtmpfs`:
+ The `devtmpfs` filesystem was developed in response to the problem of device availability during boot.
+ This filesystem is similar to the older `devfs` support, but simplified.
+ The kernel creates device files as necessary, but it also notifies `udevd` that a new device is available.
+ Upon receiving this signal, `udevd` does not create the device files, but it does perform device initialization along with setting permissions and notifying other processes that new devices are available.
+ Additionally, it creates a number of symbolic links in `/dev` to further identify devices.
+ You can find examples in the directory `/dev/disk/by-id`, where each attached disk has one or more entries.
```shell
ls -l /dev/disk/by-id
```
![[Screenshot_2023-10-18_19_14_17.png]]
+ The `udevd` process names the links by interface type, and then by manufacturer and model information, serial number, and partition (if applicable).
+ The “`tmp`” in `devtmpfs` indicates that the filesystem resides in main memory with read/write capability by user-space processes; this characteristic enables `udevd` to create these symbolic links.


#### Just skip:
+ But how does `udevd` know which symbolic links to create, and how does it create them? 
+ However, you don’t need to know any of this or any


### 3.5.2 `udevd` Operation and Configuration:
+ The `udevd` daemon operates as follows:
+ The kernel sends `udevd` a notification event, called a `uevent`, through an internal network link.
+ `udevd` loads all of the attributes in the `uevent`.
+ `udevd` parses its rules, filters and updates the `uevent` based on those rules, and takes actions or sets more attributes accordingly.
+ An incoming `uevent` that `udevd` receives from the kernel might look like this:
```shell
ACTION=change
DEVNAME=sde
DEVPATH=/devices/pci0000:00/0000:00:1a.0/usb1/1-1/1-1.2/1-1.2:1.0/host4/
target4:0:0/4:0:0:3/block/sde
DEVTYPE=disk
DISK_MEDIA_CHANGE=1
MAJOR=8
MINOR=64
SEQNUM=2752
SUBSYSTEM=block
UDEV_LOG=3
```
+ This particular event is a change to a device.
+ After receiving the `uevent`, `udevd` knows the name of the device, the `sysfs` device path, and a number of other attributes associated with the properties; it is now ready to start processing rules.
+ The rules files are in the `/lib/udev/rules.d` and `/etc/udev/rules.d` directories.
+ The rules in `/lib` are the defaults, and the rules in `/etc` are overrides. 
+ A full explanation of the rules would be tedious, and you can learn much more from the `udev(7)` manual page,


## 3.5.3 `udevadm`:
+ The `udevadm` program is an administration tool for `udevd`. 
+ You can reload `udevd` rules and trigger events, but perhaps the most powerful features of `udevadm` are the ability to search for and explore system devices and the ability to monitor `uevents` as `udevd` receives them from the kernel.
+ Let’s start by examining a system device.
+ In order to look at all of the `udev` attributes used and generated in conjunction with the rules for a device such as `/dev/sda`, run the following command:
```shell
$ udevadm info --query=all --name=/dev/sda
```
+ ![[Pasted image 20231018183627.png]]
+ The prefix in each line indicates an attribute or other characteristic of the device. 
+ In this case, the `P:` at the top is the `sysfs` device path, the `N:` is the device node (that is, the name given to the `/dev` file), `S:` indicates a symbolic link to the device node that `udevd` placed in `/dev` according to its rules, and `E:` is additional device information extracted in the `udevd` rules.


## 3.5.4 Device Monitoring:
+ To monitor `uevents` with `udevadm`, use the monitor command:
```shell
$ udevadm monitor
```
+ ![[Pasted image 20231018184050.png]]
+ There are two copies of each message in this output because the default behavior is to print both the incoming message from the kernel (marked with KERNEL) and the processing messages from `udevd`. 
+ To see only kernel events, add the `--kernel` option, and to see only `udevd` processing events, use `--udev`.
+ To see the whole incoming `uevent`, including the attributes use the `--property` option.
+ The `--udev` and `--property` options together show the `uevent` after processing.
+ You can also filter events by subsystem.
+ For example, to see only kernel messages pertaining to changes in the SCSI subsystem, use this command:
```shell
udevadm monitor --kernel --subsystem-match=scsi
```

---
# 3.6 In-Depth: SCSI and the Linux Kernel


+ **Small Computer System Interface**
+ Is a set of standards for physically connecting and transferring data between computers and peripheral devices, best known for its use with storage devices such as hard disk drives.
+ The traditional SCSI hardware setup is a host adapter linked with a chain of devices over an SCSI bus, as shown
+ ![[Pasted image 20231018195458.png]]
+ The host adapter is attached to a computer. 
+ The host adapter and devices each have an SCSI ID, and there can be 8 or 16 IDs per bus, depending on the SCSI version.
+ Some administrators might use the term SCSI target to refer to a device and its SCSI ID because one end of a session in the SCSI protocol is called the target.
+ Any device can communicate with another through the SCSI command set in a peer-to-peer relationship.
+ The computer is not directly attached to the device chain, so it must go through the host adapter in order to communicate with disks and other devices.
+ Typically, the computer sends SCSI commands to the host adapter to relay to the devices, and the devices relay responses back through the host adapter.


## `lsscsi` command:
+ ![[Pasted image 20231018200044.png]]
+ The numbers in square brackets are, from left to right, the SCSI host adapter number, the SCSI bus number, the device SCSI ID, and the LUN (logical unit number, a further subdivision of a device).
+ In this example, there are four attached adapters (`scsi0`, `scsi1`, `scsi2`, and `scsi3`), each of which has a single bus (all with bus number 0), and just one device on each bus (all with target 0).
+ The USB card reader at 2:0:0 has four logical units, though—one for each kind of flash card that can be inserted. 
+ The kernel has assigned a different device file to each logical unit.


## Driver and interface hierarchy:
+ illustrates the driver and interface hierarchy inside the kernel for this particular system configuration, from the individual device drivers up to the block drivers.
+ It does not include the SCSI generic (sg) drivers.
+ ![[Pasted image 20231018200429.png]]
+ The top layer handles operations for a class of device. For example, the sd (SCSI disk) driver is at this layer; it knows how to translate requests from the kernel block device interface into disk-specific commands in the SCSI protocol, and vice versa.
+ The middle layer moderates and routes the SCSI messages between the top and bottom layers, and keeps track of all of the SCSI buses and devices attached to the system.
+ The bottom layer handles hardware-specific actions. The drivers here send outgoing SCSI protocol messages to specific host adapters or hardware, and they extract incoming messages from the hardware.