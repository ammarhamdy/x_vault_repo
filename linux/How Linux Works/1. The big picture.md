# Levels and Layers of Abstraction 


## Layers of Abstraction in a Linux:
+ A Linux system has three main levels:
	+ _The Hardware_.
	+ _The kernel_.
	+ _Processes (user process)_.
+ ![[Pasted image 20230515103224.png]]


### Hardware: 
+ The hardware is at the base.
+ Hardware includes the memory as well as one or more central processing units (CPUs) to perform computation and to read from and write to memory. 
+ Devices such as disks and network interfaces are also part of the hardware.


### Kernel:
+ The next level up is the kernel.
+ Is the core of the operating system. 
+ The kernel is software residing (المقيمين, مقيم) in memory that tells the CPU where to look for its next task. 
+ Acting as a mediator(الوسيط), the kernel manages the hardware (especially main memory) and is the primary interface between the hardware and any running program.


### Processes (user process):
+ The running programs that the kernel manages collectively make up the system’s upper level, called user space. 
+ A more specific term for process is user process, regardless of whether a user directly interacts with the process. 
+ For example, all web servers run as user processes.


## Kernel and user processes:
+ There is a critical difference between how the kernel and the user processes run: 
	+ Kernel mode:
		+ The kernel runs in kernel mode. 
		+ Code running in kernel mode has unrestricted access to the processor and main memory. 
		+ This is a powerful but dangerous privilege that allows the kernel to easily corrupt and crash the entire system. 
		+ The memory area that only the kernel can access is called **kernel space**.
	+ User mode:
		+ The user processes run in user mode. 
		+ User mode restricts access to a (usually quite small) subset of memory and safe CPU operations. 
		+ User space refers to the parts of main memory that the user processes can access. 
		+ If a process makes a mistake and crashes, the consequences are limited and can be cleaned up by the kernel.



---
# Understanding Main Memory


## Importance of main memory:
+ Main memory is perhaps the most important. 
+ In its rawest (الخام) form, main memory is just a big storage area for a bunch of `0s` and `1s`: 
	+ Each slot for a 0 or 1 is called a bit. 
+ This is where the running kernel and processes reside (يقيم) they’re just big collections of bits. 
+ All input and output from peripheral devices flows through main memory, also as a bunch of bits. 
+ A CPU is just an operator on memory; it reads its instructions and data from the memory and writes data back out to the memory.
+ When you consider that a single **process** can easily consist of millions of bits in memory, it’s often easier to use abstract terms when talking about states.


## Image term:
+ Because it’s common to refer to the state in abstract terms rather than to the actual bits. 
+ The term **image** refers to a particular physical arrangement of bits.


---
# The Kernel


## Importance of kernel:
+ Nearly everything that the kernel does revolves around main memory. 
+ One of the kernel’s tasks is to split memory into many subdivisions, and it must maintain certain state information about those subdivisions at all times. 
+ Each process gets its own share of memory, and the kernel must ensure that each process keeps to its share.


## Kernel tasks:
+ The kernel is in charge of (المسؤول عن) managing tasks in four general system areas:
	1. **Processes** (Process Management):
		+ The kernel is responsible for determining which processes are allowed to use the CPU.
	2. **Memory** (Memory Management): 
		+ The kernel needs to keep track of all memory—what is currently allocated to a particular process, what might be shared between processes, and what is free.
	3. **Device drivers**:
		+ The kernel acts as an interface between hardware and processes. 
		+ It’s usually the kernel’s job to operate the hardware.
	4. **System calls and support**:
		+ Processes normally use system calls to communicate with the kernel.




### Process Management:
+ Process management describes the starting, pausing, resuming, scheduling, and terminating of processes.


#### Context switch:
+ The act of one process giving up control of the CPU to another process is called a context switch.
+ The kernel is responsible for context switching.


### Memory Management:
+ The kernel must have its own private area in memory that user processes can’t access.
+ Each user process needs its own section of memory.
+ One user process may not access the private memory of another process.
+ User processes can share memory.
+ Some memory in user processes can be read-only.
+ The system can use more memory than is physically present by using disk space as auxiliary (مساعد).


#### Virtual memory: 
+ Fortunately for the kernel, there is help Modern CPUs include a memory management unit (MMU) that enables a memory access scheme called virtual memory. 
+ When using virtual memory, a process does not directly access the memory by its physical location in the hardware. 
+ Instead, the kernel sets up each process to act as if it had an entire machine to itself. 
+ When the process accesses some of its memory, the MMU intercepts (يعترض) the access and uses a memory address map to translate the memory location from the process point of view into an actual physical memory location in the machine. 
+ The kernel must still initialize and continuously maintain and alter this memory address map. 
+ For example, during a context switch, the kernel has to change the map from the outgoing process to the incoming process.


#### Page table:
+ The implementation of a memory address map is called a page table.


### Device Drivers and Management:
+ The kernel’s role with devices is relatively simple. 
+ A device is typically accessible only in kernel mode because improper (غير مناسب) access such as a user process asking to turn off the power could crash the machine. 
+ A notable difficulty is that different devices rarely have the same programming interface, even if the devices perform the same task (for example, two different network cards).


### System Calls and Support:
+ System call is an interaction between a process and the kernel.
+ There are several other kinds of kernel features available to user processes. 
+ For example, system calls or `syscalls` perform specific tasks that a user process alone cannot do well or at all.
+ For example, the acts of opening, reading, and writing files all involve system calls.
+ Two system calls, `fork()` and `exec()`, are important to understanding how processes start:
	+ `fork()` When a process calls `fork()`, the kernel creates a nearly identical copy of the process.
	+ `exec()` When a process calls `exec(program)`, the kernel loads and starts program, replacing the current process.


#### Fork and exec:
+ All new **user processes** on a Linux system start as a result of `fork()`, and most of the time, you also run `exec()` to start a new **program** instead of running a copy of an existing process. 
+ A very simple example is any program that you run at the command line, such as the `ls` command to show the contents of a directory.
+ When you enter `ls` into a terminal window, the shell that’s running inside the terminal window calls `fork()` to create a copy of the shell, and then the new copy of the shell calls `exec(ls) `to run `ls`.
+ The flow of processes and system calls for starting a program like ls:
![[Pasted image 20230518230100.png]]
+ The process asking the kernel to create another process must perform a `fork()` system call.



---
# User Space


## User space:
+ The main memory that the kernel allocates for user processes is called **user space**. 
+ Because a process is simply a state or image in memory, **user space** also refers to the memory for the entire collection of running processes. 
+ You may also hear the more informal term `userland` used for user space.
+ Most of the real action on a Linux system happens in user space.
+ Though all processes are essentially (بشكل أساسي) equal from the kernel’s point of view, they perform different tasks for users.
+ Shows how an example set of components fit together and interact on a Linux system: 
	+ ![[Pasted image 20230519105135.png]]
	+ Basic services are at the bottom level closest to the kernel, utility services are in the middle, and applications that users touch are at the top. 


## User processes levels:
+ The bottom level tends to consist of small components that perform single, uncomplicated tasks. 
+ The middle level has larger components such as mail, print, and database services. 
+ Finally, components at the top level perform complicated tasks that the user often controls directly.


## Component use each others:
+ Components also use other components. Generally, if one component wants to use another, the second component is either at the same service level or below.


---
# Users


## What is the user:
+ ==A user is an entity that can run processes and own files==.
+ A user is most often associated with a username; for example, a system could have a user named `billyjoe`. 
+ However, the kernel does not manage the usernames; instead, it identifies users by simple numeric identifiers called user IDs.
+ Users exist primarily to support permissions and boundaries. 
+ Every user-space process has a user owner, and processes are said to run as the owner. 
+ A user may terminate or modify the behavior of its own processes (within certain limits), but it cannot interfere with other users’ processes.
+ A Linux system normally has a number of users in addition to the ones that correspond to the real human beings who use the system.


## Root user:
+ The most important user to know about is root. 
+ The root user is an exception to the preceding rules because root may terminate and alter another user’s processes and access any file on the local system. 
+ For this reason, root is known as the superuser.
+ As powerful as the root user is, it still runs in the operating system’s user mode, not kernel mode.


## Group:
+ Groups are sets of users. 
+ The primary purpose of groups is to allow a user to share file access to other members of a group.