

Memory on a modern Linux system is governed and managed by the kernel.
The hardware memory on the system is shared by all the processes on the system, through a method called virtual addressing. 
The physical memory can be referenced by a number of processes, any of which may think they are able to address more memory than they actually can.
Virtual addressing allows many processes to access the same memory without conflicts or crashes.
It does this by allocating certain areas of a physical (or virtual) hard disk to be used in place of physical RAM.
Memory is divided into blocks of equally sized units that can be addressed like any other resource on the system.
Not only can the system access memory from local system addresses, but it can also access memory that is located elsewhere, such as on a different computer, a virtual device, or even on a volume that is physically located on another continent!


## Kernel space:
+ It’s important to note the difference between user space and kernel space. 
+ Kernel space is where code for the kernel is stored and executed. 
+ This is generally in a “protected” range of memory addresses and remains isolated from other processes with lower privileges. 


## User space:
+ User space, on the other hand, is available to users and programs. 
+ They communicate with the Kernel through “system call” APIs that act as intermediaries between regular programs and the Kernel.
+ This system of separating potentially unstable or malicious programs from the critical work of the Kernel is what gives Linux systems the stability and resilience that application developers rely on.



----
# Viewing Memory


Executing the `free` command without any options provides a snapshot of the memory being used at that moment.
![[Pasted image 20240226174310.png]]


If you want to monitor memory usage over time with the `free` command, then you can execute it with the `-s` option (how often to update) and specify that number of seconds. 
For example, executing the following `free` command would update the output every ten seconds:
![[Pasted image 20240226174403.png]]
To make it easier to interpret what the `free` command is outputting, the `-m` or `-g` options can be useful by showing the output in either megabytes or gigabytes, respectively. Without these options, the output is displayed in bytes.


## Reading the output of the `free` command:
+ ‌⁠​​⁠​ **Descriptive Header:**
![[Pasted image 20240226174517.png]]
+ **Physical Memory Statistics:**
![[Pasted image 20240226174534.png]]
+ **Memory Adjustment:**
	+ The third line represents the amount of physical memory after adjusting those values by not taking into account any memory that is in use by the kernel for buffers and caches. 
	+ Technically, this "used" memory could be "reclaimed" if needed:
![[Pasted image 20240226174616.png]]
+ **Swap Memory:**
	+ The fourth line of output refers to swap memory, also known as virtual memory.
	+ This is space on the hard disk that is used like physical memory when the amount of physical memory becomes low.
	+ Effectively, this makes it seem that the system has more memory than it does, but using swap space can also slow down the system:
![[Pasted image 20240226174711.png]]


## When memory become low:
+ If the amount of memory and swap that is available becomes very low, then the system will begin to automatically terminate processes, making it critical to monitor the system's memory usage.
+ An administrator that notices the system becoming low on free memory can use `top` or `kill` to terminate the processes of their own choice, rather than letting the system choose.







