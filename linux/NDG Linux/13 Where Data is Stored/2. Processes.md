

## `proc` `dev` `sys` directories:
+ The kernel provides access to information about active processes through a pseudo filesystem that is visible under the `/proc` directory. 
+ Hardware devices are made available through special files under the `/dev` directory, while information about those devices can be found in another pseudo filesystem under the `/sys` directory.


## Wheres is these directories:
+ Pseudo filesystems appear to be real files on disk but exist only in memory.
+ Most pseudo file systems such as `/proc` are designed to appear to be a hierarchical tree off the root of the system of directories, files and subdirectories, but in reality only exist in the system's memory, and only appear to be resident on the storage device that the root file system is on.


## `proc` directory how to see inside:
+ The `/proc` directory not only contains information about running processes, as its name would suggest, but it also contains information about the system hardware and the current kernel configuration.
+ The `/proc` directory is read, and its information utilized by many different commands on the system, including but not limited to `top`, `free`, `mount`, `umount` and many many others.


## Content of `proc` directory:
![[Pasted image 20240226171001.png]]
+ The output shows a variety of named and numbered directories.
+ There is a numbered directory for each running process on the system, where the name of the directory matches the process ID (PID) for the running process.
+ For example, the numerals `72` denote PID 72, a running program, which is represented by a directory of the same name, containing many files and subdirectories that describe that running process, it’s configuration, use of memory, and many other items.


## About  running kernel:
+ There are also a number of regular files in the `/proc` directory that provide information about the running kernel:

|File|Contents|
|---|---|
|`/proc/cmdline`|Information that was passed to the kernel when it was first started, such as command line parameters and special instructions|
|`/proc/meminfo`|Information about the use of memory by the kernel|
|`/proc/modules`|A list of modules currently loaded into the kernel to add extra functionality|


## Even the root can not change this:
+ While most of the "files" underneath the `/proc` directory cannot be modified, even by the root user, the "files" underneath the `/proc/sys` directory are potentially meant to be changed by the root user. 
+ Modifying these files changes the behavior of the Linux kernel.
+ Direct modification of these files causes only temporary changes to the kernel. 
+ To make changes permanent (persistent even after rebooting), entries can be added to the appropriate section of the `/etc/sysctl.conf` file.
+ For example, the `/proc/sys/net/ipv4` directory contains a file named `icmp_echo_ignore_all`. 
+ If that file contains a zero `0` character, as it normally does, then the system will respond to `icmp` requests.
+ If that file contains a one `1` character, then the system will not respond to `icmp` requests:
![[Pasted image 20240226171541.png]]




---
# Process Hierarchy


When the kernel finishes loading during the boot procedure, it starts the init process and assigns it a PID of 1.
This process then starts other system processes, and each process is assigned a PID in sequential order.


On a **System V**-based system, the init process would be the `/sbin/init` program. On a **systemd**-based system, the `/bin/systemd` file is typically executed but is almost always a link to the `/lib/system/systemd` executable.
Regardless of which type of system init process that is being run, the information about the process can be found in the `/proc/1` directory.



## Parent process id `PPID`:
+  When one process starts another process, the process that performs the starting is called the parent process and the process that is started is called the child process. 
+ When viewing processes, the parent PID is labeled PPID.


## Fixed ids:
+ When the system has been running for a long time, it may eventually reach the maximum PID value, which can be viewed and configured through the `/proc/sys/kernel/pid_max` file. 
+ Once the largest PID has been used, the system "rolls over" and continues seamlessly by assigning PID values that are available at the bottom of the range.


## Process tree:
+ Processes can be “mapped” into a family tree of parent and child couplings. 
+ If you want to view this tree, the command `pstree` displays it:
```bash
am@ubuntu:~$ pstree
systemd─┬─ModemManager───3*[{ModemManager}]
        ├─NetworkManager───3*[{NetworkManager}]
        ├─accounts-daemon───3*[{accounts-daemon}]
        ├─avahi-daemon───avahi-daemon
        ├─bluetoothd
        ├─colord───3*[{colord}]
        ├─cron
        ├─cups-browsed───3*[{cups-browsed}]
        ├─cupsd
        ├─dbus-daemon
        ├─gdm3─┬─gdm-session-wor─┬─gdm-x-
...
```



---
# Viewing Process Snapshot


## `ps` command:
+ Another way of viewing processes is with the `ps` command. 
+ By default, the `ps` command only shows the current processes running in the current shell. 
+ Ironically, even though you are trying to obtain information about processes, the `ps` command includes itself in the output:
```
am@ubuntu:~$ ps
    PID TTY          TIME CMD
   4375 pts/0    00:00:00 bash
   4476 pts/0    00:00:00 ps

```
+ If you run `ps` with the option `--forest`, then, similar to the `pstree` command, it shows lines indicating the parent and child relationship:
```
am@ubuntu:~$ ps --forest
    PID TTY          TIME CMD
   4375 pts/0    00:00:00 bash
   4486 pts/0    00:00:00  \_ ps
```
+ To be able to view all processes on the system execute either the `ps aux` command or the `ps -ef` command:
![[Pasted image 20240226172542.png]]
![[Pasted image 20240226172628.png]]


## View an individual user's processes:
+ An administrator may be more concerned about the processes of another user. 
+ There are several styles of options that the `ps` command supports, resulting in different ways to view an individual user's processes.
+ To use the traditional UNIX option to view the processes of a specific user, use the `-u` option:
```
am@ubuntu:~$ ps -u root
    PID TTY          TIME CMD
      1 ?        00:00:01 systemd
      2 ?        00:00:00 kthreadd
      3 ?        00:00:00 rcu_gp
      4 ?        00:00:00 rcu_par_gp
      5 ?        00:00:00 slub_flushwq
      6 ?        00:00:00 netns
      8 ?        00:00:00 kworker/0:0H-events_highpri
     10 ?        00:00:00 kworker/u16:0-events_unbound
```



---
# Viewing Processes in Real Time



The `top` command has a dynamic, screen-based interface that regularly updates the output of running processes.


By default, the output of the `top` command is sorted by the percentage % of CPU time that each process is currently using, with the higher values listed first, meaning more CPU-intensive processes are listed first


There is an extensive amount of interactive commands that can be executed from within the running `top` program. Use the **H** key to view a full list.


## Actions that top can do:
+ An administrator that is running the top command can then take one of two actions:

| Key   | Action                              |
| ----- | ----------------------------------- |
| **K** | Terminate the runaway process.      |
| **R** | Adjust the priority of the process. |


### Kill process:
+ Pressing the **K** key while the `top` command is running will prompt the user to provide the PID and then a signal number.
+ Sending the default signal requests the process terminate, but sending signal number `9`, the `KILL` signal, forces the process to terminate.


### Change the priority of the process:
+ Pressing the **R** key while the `top` command is running will prompt the user for the process to renice, and then for a niceness value. 
+ Niceness values can range from -20 to 19, and affect priority.
+ Only the root user can use a niceness value that is a lower number than the current one, or a negative niceness value, which causes the process to run with an increased priority. 
+ Any user can provide a niceness value that is higher than the current niceness value, which causes the process to run with a lowered priority.


## Some statistics `top` is showing:
+ The load averages shown in the first line of output from the `top` command indicate how busy the system has been during the last one, five and fifteen minutes.
+ This information can also be viewed by executing the `uptime` command or directly by displaying the contents of the `/proc/loadavg` file:
```
sysadmin@localhost:~$ cat /proc/loadavg
0.12 0.46 0.25 1/254 3052
```
+ The first three numbers in this file indicate the load average over the ==last one, five and fifteen minute intervals.==
+ Then Number of Processes: The fourth value is a fraction which shows the number of processes currently executing code on the CPU `1` and the total number of processes `254`.
![[Pasted image 20240226173626.png]]
+ Last PID: The fifth value is the last PID value that executed code on the CPU.
![[Pasted image 20240226173702.png]]


## Understand these statistics:
 + The number reported as a load average is proportional to the number of CPU cores that are able to execute processes. On a single-core CPU, a value of one (`1`) would mean that the system is fully-loaded. 
 + On a four core CPU, a value of `1` would mean that the system is only 1/4 or 25% loaded.


## Other adv:
 + Another reason administrators like to keep the `top` command running is the ability to monitor memory usage in real-time. Both the `top` and the `free` command display statistics for how overall memory is being used.
+ The `top` command can also show the percentage of memory used by each process, so a process that is consuming an inordinate amount of memory can quickly be identified.



