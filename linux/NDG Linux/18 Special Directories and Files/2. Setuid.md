

When the `setuid` permission is set on an executable binary file (a program) the binary file is run as the owner of the file, not as the user who executed it.


This permission is set on a handful of system utilities so that they can be run by normal users, ==but executed with the permissions of root==, providing access to system files that the normal user doesn't normally have access to.


The permissions on `/etc/shadow` do not allow normal users to view (or modify) the file.

Now consider the `passwd` command. 
When this command runs, it modifies the `/etc/shadow` file, which seems impossible because other commands that the `normal_user` runs that try to access this file fail.

So, why can the `normal_user` user modify the `/etc/shadow` file while running the `passwd` command when normally this user has no access to the file?

The `passwd` command has the special `setuid` permission set. 

When the `passwd` command is run, and the command accesses the `/etc/shadow` file, the system acts as if the user accessing the file is the owner of the `passwd` command (the root user), not the user who is running the command.

```sh
am@ubuntu:~$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 64152 Feb  6 14:53 /usr/bin/passwd
```

The `setuid` permission is represented by the `s` in the owner permissions where the execute permission would normally be represented.

A lowercase `s` means that both the `setuid` and execute permission are set, while an uppercase `S` means that only `setuid` and not the user execute permission is set.

Special permissions can be set with the `chmod` command.

To add or remove the `setuid` permission symbolically, run:

```sh
chmod u+s file
chmod u-s file
```

To add or remove the `setuid` permission numerically, add 4000 to the file's existing permissions:

```sh
chmod 4775 file
chmod 0775 file
```


When a three-digit code is provided, the `chmod` command assumes that the first digit before the three-digit code is 0. 

Only when four digits are specified is a special permission set.

