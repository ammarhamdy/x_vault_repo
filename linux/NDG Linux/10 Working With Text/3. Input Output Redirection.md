

Input/Output (I/O) redirection allows for command line information to be passed to different streams. Before discussing redirection, it is important to understand the standard streams.


## STDIN:    
+ Standard input, or STDIN, is information entered normally by the user via the keyboard. 
+ When a command prompts the shell for data, the shell provides the user with the ability to type commands that, in turn, are sent to the command as STDIN.


## STDOUT:
+ Standard output, or STDOUT, is the normal output of commands. When a command functions correctly (without errors) the output it produces is called STDOUT. 
+ By default, STDOUT is displayed in the terminal window where the command is executing. 
+ STDOUT is also known as stream or channel #1.


## STDERR:
+ Standard error, or STDERR, is error messages generated by commands. 
+ By default, STDERR is displayed in the terminal window where the command is executing. STDERR is also known as stream or channel #2.
    
    ‌⁠​​⁠​ 
## I/O Redirection:
+ I/O redirection allows the user to redirect STDIN so that data comes from a file and STDOUT/STDERR so that output goes to a file.
+ Redirection is achieved by using the arrow `<` `>` characters.



----
# STDOUT


Using the `>` character, the output can be redirected to a file instead:
```bash
echo "Line 1" > example.txt
```
It is important to realize that the single arrow overwrites any contents of an existing file
It is also possible to preserve the contents of an existing file by appending to it. 
Use two arrow `>>` characters to append to a file instead of overwriting it
```bash
echo "Another line" >> example.txt
```



---
# STDERR


STDERR can be redirected similarly to STDOUT. 
When using the arrow character to redirect, stream #1 (STDOUT) is assumed unless another stream is specified. 
Thus, stream #2 must be specified when redirecting STDERR by placing the number `2` preceding the arrow `>` character.


## `1>` stream 1:
+ `stream #1` is the STDOUT.


## Example:
```
sysadmin@localhost:~$ ls /fake
ls: cannot access /fake: No such file or directory
```
+  The output is clearly an error message, but how could you tell that it is being sent to STDERR? One easy way to determine this is to redirect STDOUT:
```
sysadmin@localhost:~$ ls /fake > output.txt
ls: cannot access /fake: No such file or directory
```
+ Because all command output goes either to STDOUT or STDERR, the output displayed above must be STDERR.
+ The STDERR output of a command can be sent to a file:
```bash
sysadmin@localhost:~$ ls /fake 2> error.txt
```



---
# Redirecting Multiple Streams


## Redirect both STDOUT and STDERR:
+ It is possible to direct both the STDOUT and STDERR of a command at the same time.
+ The following command produces both STDOUT and STDERR because one of the specified directories exists and the other does not:
```bash
sysadmin@localhost:~$ ls /fake /etc/ppp
ls: cannot access /fake: No such file or directory
/etc/ppp:
ip-down.d  ip-up.d
```
+ If only the STDOUT is sent to a file, STDERR is still printed to the screen:
```bash
sysadmin@localhost:~$ ls /fake /etc/ppp > example.txt
ls: cannot access /fake: No such file or directory
sysadmin@localhost:~$ cat example.txt
/etc/ppp:
ip-down.d
ip-up.d
```
+ If only the STDERR is sent to a file, STDOUT is still printed to the screen:
```bash
sysadmin@localhost:~$ ls /fake /etc/ppp 2> error.txt
/etc/ppp:
ip-down.d
ip-up.d
sysadmin@localhost:~$ cat error.txt
ls: cannot access /fake: No such file or directory
```
+ Both STDOUT and STDERR can be sent to a file by using the ampersand `&` character in front of the arrow `>` character. 
+ The `&>` character set means both `1>` and `2>`:
```bash
sysadmin@localhost:~$ ls /fake /etc/ppp &> all.txt
sysadmin@localhost:~$ cat all.txt
ls: cannot access /fake: No such file or directory
/etc/ppp:
ip-down.d
ip-up.d
```
+ If you don't want STDERR and STDOUT to both go to the same file, they can be redirected to different files by using both `>` and `2>`. 
+ For example, to direct STDOUT to `example.txt` and STDERR to `error.txt` execute the following:
```bash
abc@abc:~$ ls /fake /etc/ppp > example.txt 2> error.txt
abc@abc:~$ cat error.txt
ls: cannot access /fake: No such file or directory
sysadmin@localhost:~$ cat example.txt
/etc/ppp:
ip-down.d
ip-up.d
```



----
# STDIN




Most Linux users end up redirecting STDOUT routinely, STDERR on occasion, and STDIN very rarely.

## Command with no file given as input:
+ There are very few commands that require you to redirect STDIN because with most commands if you want to read data from a file into a command, you can specify the filename as an argument to the command.
+ For some commands, if you don't specify a filename as an argument, they revert to using STDIN to get data. For example, consider the following `cat` command:
```
sysadmin@localhost:~$ cat
blablabla

```
+ If you do attempt the `cat` command without arguments, kill the process and return to the prompt by using **Ctrl**+**C**.
+ However, if the output of the `cat` command were redirected to a file, then this method could be used either to add text to an existing file or to place text into a new file.
```bash
sysadmin@localhost:~$ cat > new.txt
Hello
How are you?
Goodbye
sysadmin@localhost:~$ cat new.txt                     Hello
How are you?
Goodbye
```


## Translate command:
+ The `tr` command took the STDIN from the keyboard and converted all lower-case letters before sending STDOUT to the screen.
+ It would seem that a better use of the `tr` command would be to perform translation on a file, not keyboard input. 
+ However, the `tr` command does not support file name arguments:
```bash
sysadmin@localhost:~$ cat example.txt
/etc/ppp:
ip-down.d
ip-up.d
sysadmin@localhost:~$ tr 'a-z' 'A-Z' example.txt
tr: extra operand `example.txt'
Try `tr --help' for more information
```
+ It is possible, however, to tell the shell to get STDIN from a file instead of from the keyboard by using the `<` character:
```bash
sysadmin@localhost:~$ tr 'a-z' 'A-Z' < example.txt
/ETC/PPP:
IP-DOWN.D
IP-UP.D
```
+ Most commands do accept file names as arguments, so this use case is relatively rare.
+ One last note to save the resulting output, redirect it into another file:
```bash
abc@abc:~$ tr 'a-z' 'A-Z' < example.txt > newexample.txt
abc@abc:~$ cat newexample.txt
/ETC/PPP:
IP-DOWN.D
IP-UP.D
```









