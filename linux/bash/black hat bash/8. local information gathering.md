
# Filesystem Hierarchy Standard (`FHS`)

Describes the structure of directories and their locations on a Linux system.

The Linux filesystem’s hierarchy starts at the root (`/`) directory, which is the entry point into the filesystem directory tree structure.

See [[2. Basic commands and directory hierarchy]]

| Directory | Purpose                                                              |
| --------- | -------------------------------------------------------------------- |
| /         | Root of the filesystem hierarchy                                     |
| /bin      | Essential user binaries (basic commands needed in single-user mode)  |
| /boot     | Boot loader files (kernel, initrd, GRUB configs)                     |
| /dev      | Device files representing hardware and virtual devices               |
| /etc      | System-wide configuration files                                      |
| /home     | User home directories                                                |
| /lib      | Essential shared libraries and kernel modules                        |
| /media    | Mount points for removable media (USB, CD-ROM)                       |
| /mnt      | Temporary mount points for filesystems                               |
| /opt      | Optional software packages                                           |
| /proc     | Virtual filesystem for process and kernel information                |
| /root     | Home directory for the root user                                     |
| /run      | Runtime variable data (process IDs, sockets, system info since boot) |
| /sbin     | Essential system binaries (administrative commands)                  |
| /srv      | Data for services (web, FTP, etc.)                                   |
| /sys      | Virtual filesystem for kernel and device information                 |
| /tmp      | Temporary files (cleared on reboot in many systems)                  |
| /usr      | User programs, libraries, documentation, and secondary binaries      |
| /var      | Variable data (logs, spool files, caches, databases)                 |

# Environment Variables

When compromising a host, it’s often useful to dump its environment variables by using the `env` or `printenv` commands.

# Sensitive Information in Bash Profiles

Here are some common profile files to look for: 
+ `/etc/profile` 
+ `/etc/bashrc` 
+ `~/.bashrc`
+ `~/.profile`
+ `~/.bash_profile` 
+ `~/.env` 
+ `~/.bash_login` 
+ `~/.bash_logout`
Shells other than bash, such as the Z Shell, can also exist on a system you might want to look at files such as:
+ `/etc/zprofile` 
+ `/etc/zshrc`
+ `~/.zprofile`
+ `~/.zshrc`

# Learn more about shell
Use the man command to learn more about the environment and profile files of the various shells. For example, run:
+ `man bash` for the **bash shell** 
+ `man zsh` for the **Z Shell** 
+ `man csh` for the **C Shell**.


# Local Accounts

Linux systems come with several default users and groups. You can find user accounts in `/etc/passwd` and groups in `/etc/group`, which even low-privileged users should be able to read. 

These files don’t contain sensitive data but can help you figure out other directories and files to look for, as everything on a Linux system is owned by a user and group.


# Valid Shells

## Default shell:

```sh
grep -e "#DSHELL" /etc/adduser.conf
```

```sh
grep -e "SHELL=" /etc/default/useradd
```


# Processes

Each process on a Linux host has a dedicated directory under `/proc` that is named after its process identifier (PID), which is a numerical value.

```sh
ls /proc
```

## init process
```sh
ls -1 /proc/1/
```
Each directory on it (`/proc/1/`) contains many files.

```sh
cat /proc/1/cmdlineroc/1/cmdline
# /sbin/initsplash
```

## The following files contain useful information:

| Path                  | Description |
|------------------------|-------------|
| `/proc/<pid>/cmdline` | Contains the full command used to start the process. |
| `/proc/<pid>/cwd`     | Points to the working directory of the process. |
| `/proc/<pid>/environ` | Contains the environment variables at the process’s start time. |
| `/proc/<pid>/exe`     | Points to the binary that started the process. |
| `/proc/<pid>/task`    | Contains subdirectories for each thread started by the process. |
| `/proc/<pid>/status`  | Contains information about the process, such as its state, virtual memory size, number of threads, thread ID, and process umask (a four-digit value used to determine the permissions of freshly created files). |
| `/proc/<pid>/fd`      | Contains the file descriptors in use. File descriptors are nonnegative (unsigned) integers used by processes to describe open files. |
You can find a well-explained list of these files in the proc manual page (by running `man proc`)


# Running `ps`
Utilities such as `ps` can enable us to explore processes without having to manually navigate the /proc directory.

```sh
ps x -o user -o pid -o cmd
```

**`x`** → Show all processes **owned by you**, even those without a controlling terminal (background daemons, services you started, etc.).

**`-o`** → "output format" option. Lets you specify which columns to display. 
You can repeat it multiple times:
- **`-o user`** → Displays the user that owns the process.
- **`-o pid`** → Displays the process ID.
- **`-o cmd`** → Displays the command that started the process (with arguments).


# The Operating System

Operating systems may place information about themselves in different places, but for the most part, you’ll find it under the `/etc` directory.

Check the following locations: `/etc/os-release`, `/etc/issue`, `/usr/lib/os-release`, `/proc/version`, `/etc/*-release`, and `/etc/*-version`.

Try running 
+ `uname -o` or `uname -a`
+ `lsb_release`
+ `hostnamectl` (==very simple and help-full==)
+ `hostname`.


# Collecting User Sessions

To view the current users on a system, use the `w` or `who` commands

The `last` command shows historical logins taken from the file `/var/log/wtmp` 

Another useful command is `lastb` (last bad). 
This command displays a list of bad login attempts, taken from `/var/log/btmp`, if such a file exists on the filesystem.

Files such as `/var/run/utmp` and `/var/log/wtmp` are binary files. 
If you try to read them by using the cat command, the output will be garbled.
Some systems may have the `utmpdump` command, which takes in these files as arguments and prints them in proper format to the screen.

For normal users, the history file is usually saved under `/home/<user>/.bash_history`.
```ls
find / -name ".*_history" -type f
```


# Networking

On a compromised host, a simple way to obtain all network interfaces is by looking at the files under the `/sys/class/net` directory.
```sh
ls /sys/class/net
```

## `/sys/devices/virtual/net/`
Each file is a symbolic link containing the name of a network interface,
and each link points to a directory under `/sys/devices/virtual/net/`
```sh
ls -l /sys/devices/virtual/net/
```
You could also use this network interface analysis to identify whether a network device is physical or virtual. 
It’s worth noting that an administrator ==can change network interface names==, so these aren’t reliable indicators.

## `/proc/net/route`
Print all network interfaces without using special network utilities is by inspecting the `/proc/net/route` file
```sh
cat /proc/net/route
```
The output: 
in the first line, under Gateway, the value `010A10AC` represents the gateway IP address of the network interface.

## `the /proc/net/fib_trie` 
Information about `ip` addresses
```sh
awk '/32 host/ { print f } {f=$2}' /proc/net/fib_trie | sort | uniq
```

## `/sys/class/net/eth0/address`
Show information about `mac` address
```sh
cat /sys/class/net/eth0/address
```


## `/proc/net/tcp` 

`/proc/net/tcp` is a **procfs pseudo-file** (text) that lists the kernel's current IPv4 TCP sockets. It’s not a regular file on disk — the kernel generates its contents on the fly. 

Each line (after the header) describes one socket with several fields in compact, mostly-hex form.

kernel’s live table of IPv4 TCP sockets.
**Header:**

**`sl`** — kernel table slot (sequence number for that line).

**`local_address`** — `IP:PORT` for the local endpoint, both in hex.
- IP is in **little-endian** hex (bytes reversed). Example: `0100007F` → `127.0.0.1`.
- Port is hex in normal order: `0035` → `0x35` → `53`.

**`rem_address`** 
`IP:PORT` of remote endpoint in same encoding. `00000000:0000` means “no remote” (e.g., LISTEN).

**`st`** — socket **state**, shown as a 2-hex-digit code. Common values:
- `01` = ESTABLISHED
- `02` = SYN_SENT
- `03` = SYN_RECV
- `04` = FIN_WAIT1
- `05` = FIN_WAIT2
- `06` = TIME_WAIT
- `07` = CLOSE
- `08` = CLOSE_WAIT
- `09` = LAST_ACK
- `0A` = LISTEN
- `0B` = CLOSING

**`tx_queue` / `rx_queue`** — transmit / receive queue sizes in hex (bytes waiting).

**`tr`** — timer_active (internal timer state code).

**`tm->when`** — timer value (kernel jiffies until event) in `hex/dec `depending on kernel version.

**`retrnsmt`** — retransmit timer / retransmit count (format varies).

**`uid`** — numeric user ID owning the socket.

**`timeout`** — internal timeout (kernel-specific).

**`inode`** — inode number of the socket — useful to map socket → process: many tools (and manual checks) use this.

**How to decode addresses quickly**
```python
# example: convert 0100007F to 127.0.0.1
python3 -c "import socket,struct; print(socket.inet_ntoa(struct.pack('<L',0x0100007F)))"
# prints: 127.0.0.1
```


# Firewall Rules

A firewall table may include rules that block certain networks or individual IP addresses from communicating with the host.
A common host firewall found on Linux servers is `iptables`
```sh
iptables -L --line-numbers -v
```

# Network Interface Configuration Files

Network interfaces may have dedicated configuration files that, for example, configure a network IP address statically for a specific interface or ensure that a network card is enabled on boot by default.

Network configurations files can be found: 
+ `/etc/network/interfaces` 
+ `/etc/network/interfaces.d/`
+ `/etc/netplan/` 
+ `/lib/netplan/`
+ `/run/netplan/`
+ `/etc/sysconfig/network-scripts/`


# Software Installations

One way to investigate installed software is with a package manager.
Advanced Package Tool (APT)
```sh
apt list --installed
```

You can get a slightly nicer output by using `dpkg` instead.
```sh
dpkg -l
```

Other:
+ `yum list installed`
+ `apk list --installed`
+ `rpm -qa`


You could use these package names and versions as lookup queries on websites that source vulnerability data, such as the National Vulnerability Database (https://nvd.nist.gov) or the MITRE Common Vulnerabilities and Exposures (CVE) database (https://cve.mitre.org).

# Storage

Linux systems can mount remote storage systems as local directories (usually under the `/mnt` directory).

These can act as an integral part of the operating system.

You’ll see remote storage implemented using network-attached storage or storage area network devices and protocols like Network File System or Common Internet File System.

## `lsblk`
First, let’s look at which block devices exist by using the command `lsblk`.
==Block devices are data storage devices such as CDs, floppy disks, and hard disks==.

## `/proc/partitions`
Another way to view the list of partitions is by reading /proc/partitions
```sh
cat /proc/partitions
```

## `/proc/mounts`
The /proc filesystem also exposes a file named /proc/mounts, which provides a list of all mounts, their mount options, and additional attributes about the mount points
```sh
cat /proc/mounts
```

## `mount`
Alternatively, you could just call the mount command to get this
information

## `df`
A quick way to get a view of the various mounted filesystems is by using the `df` command, which will also indicate the available and total disk sizes of each filesystem
```sh
df -h -T
```
The `-h` and `-T` flags will print out a human-readable version of the output and the filesystem type, respectively.

# The Filesystem Tab File

The `/etc/fstab` file is a static configuration file that controls the mounting of devices and partitions.

You can mount a device or partition at specific filesystem locations by using special options that control what can and cannot be done using the mount point.

Here are a few mount options that can be beneficial.

| Option        | Description                                                                 |
|---------------|-----------------------------------------------------------------------------|
| **dev**       | Interprets special block devices, such as device files.                     |
| **nodev**     | The opposite of `dev`; will not interpret special block devices.            |
| **noexec**    | Forbids the execution of binaries. Scripts such as `bash` will still work.  |
| **suid**      | Allows use of programs set with the **setuid** flag (run with file owner’s permissions). |
| **nosuid**    | The opposite of `suid`; disallows use of **setuid** programs.               |
| **exec**      | Allows execution of binaries and other types of files.                      |
| **ro**        | Forbids writing into the filesystem (read-only).                            |
| **rw**        | Allows writing into the filesystem as well as reading.                      |
| **nosymfollow** | Restricts following symbolic links; creating links is still allowed.      |
| **defaults**  | Uses the following mount options: `rw`, `suid`, `dev`, `exec`, and others.  |


# logs 

On Linux systems, both system and application log-files are usually written to the /var/log directory. Custom applications can write their logs anywhere but generally write them to files under the `/var` directory too

Here is an example find command that can search for log-files:
```sh
find / -name "*.log" -o -name "*.txt" -o -name "*.out" -type f 2> /dev/null
```

## System Logs

| Log File                | Description                                                                 |
|--------------------------|-----------------------------------------------------------------------------|
| `/var/log/auth.log`      | Authentication logs (login attempts, sudo, etc.) – used on Debian/Ubuntu.  |
| `/var/log/secure`        | Authentication logs – used on RHEL/CentOS.                                 |
| `/var/log/audit/audit.log` | Security audit framework logs.                                            |
| `/var/log/dmesg`         | Kernel ring buffer messages (hardware, drivers, boot info).                |
| `/var/log/messages`      | General system messages (boot, kernel, services).                          |
| `/var/log/syslog`        | General system activity logs (Debian/Ubuntu).                              |
| `/var/log/faillog`       | Failed login attempt records.                                              |
| `/var/log/lastlog`       | Records of the last login for all users.                                   |
| `/var/log/dpkg`          | Logs from Debian package manager.                                          |
| `/var/log/boot.log`      | Boot process logs.                                                         |
| `/var/log/cron`          | Cron job execution logs.                                                   |


# Kernels and Bootloaders

The main component of operating systems such as Linux is called the
kernel. 

==The kernel is responsible for core functionalities such as process and memory management, drivers, security, and more==. 

It is a highly complex piece of software and, as such, is prone to vulnerabilities.

To check the kernel version
```sh
uname -r
```

A Linux system could have more than one kernel version installed to allow for rollbacks in cases of system failure. 
Kernel files are located under the /boot directory.
You can also find out which kernels are installed by running:

The **`rpm` command** is the **Red Hat Package Manager** command-line tool used on **RHEL-based Linux distributions**
```sh
rpm -qa | grep kernel
```

```sh
ls -l /boot | grep "vmlinuz-"
```


# Configuration Files

Configuration files primarily live under the **`/etc`** directory.  
They **may or may not** have an associated file extension, such as:  
- `*.conf`  
- `*.cfg`  
- `*.ini`  
- `*.cnf`  
- `*.cf`  

You might also find configuration files under users’ hidden directories:  
- `/home/user/.config/`  
- `/home/user/.local/`

```sh
find / -name "*.conf" -o -name "*.cf" -o -name "*.ini" -o -name "*.cfg" -type f 2> /dev/null
```


# Scheduled Tasks

On Linux, we have two common mechanisms for scheduling tasks: `Cron` and `At`.

`At` is another job-scheduling tool in Linux, though it’s less common than `Cron` and uses a simpler approach.

```sh
at now + 1 minute
```
We start by specifying the schedule, using now + 1 minute to tell At to run commands one minute from now.

Here are a few examples of schedule definitions:
```sh
at 22:00             # run at 10 pm
at 11pm + 3 days     # runs at 11 pm three days from today
at tomorrow          # tomorrow at the current time
at Sunday            # on Sunday at the current time
at May 27 2050       # runs on May 27, 2050
```
At will drop your shell into a dedicated command prompt (`at>`), where you can enter shell commands line by line.
To save the job, use `ctrl-D`

The at command also provides a way to see the queue of jobs (by using
`atq`) and remove them (by using `atrm`).
```sh
atq
```
you can generally find the job definition located under `/var/spool/cron/atjobs`

You can remove queued jobs by using `atrm` followed by the job ID:
```sh
atrm 1
```

Like `Cron`, `At` uses deny (`/etc/at.deny`) and allow (`/etc/at.allow`) files to determine which users can schedule jobs.


# Hardware

You can collect hardware-related information, such as memory allocation details, the number of CPUs and cores, and the manufacturer of hardware components such as the motherboard, network card, and other peripherals. 

To collect these details, you use commands such as `lshw`, `dmidecode`, and `hwinfo`.

These commands may show only partial information when run using
a non-privileged user.