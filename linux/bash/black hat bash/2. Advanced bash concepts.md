
# Test operators

## [File Test Operators](https://ss64.com/bash/test.html) 

## String comparison operators
| Operator | Description                                                                 |
|----------|-----------------------------------------------------------------------------|
| =        | Checks whether a string is equal to another string                          |
| ==       | Synonym of `=` when used within `[[ ]]` constructs                          |
| !=       | Checks whether a string is not equal to another string                      |
| <        | Checks whether a string comes before another string (in alphabetical order) |
| >        | Checks whether a string comes after another string (in alphabetical order)  |
| -z       | Checks whether a string is null                                             |
| -n       | Checks whether a string is not null                                         |
```sh
VARIABLE_ONE="nostarch"
VARIABLE_TWO="nostarch"
if [[ "${VARIABLE_ONE}" == "${VARIABLE_TWO}" ]]; then
```
## Integer comparison operators
| Operator | Description                                                        |
| -------- | ------------------------------------------------------------------ |
| -eq      | Checks whether a number is equal to another number                 |
| -ne      | Checks whether a number is not equal to another number             |
| -ge      | Checks whether a number is greater than or equal to another number |
| -gt      | Checks whether a number is greater than another number             |
| -lt      | Checks whether a number is less than another number                |
| -le      | Checks whether a number is less than or equal to another number    |
```sh
VARIABLE_ONE="10"
VARIABLE_TWO="20"
if [[ "${VARIABLE_ONE}" -gt "${VARIABLE_TWO}" ]]; then
...
```


---

# Function

```sh
say_name(){
	echo "Black Hat Bash"
}
```

## Returning Values

Like commands and their exit statuses, functions can return values using the return keyword. 

If there is no return statement, the function will return the code of the last command it ran.

```sh
check_if_root(){
	if [[ "${EUID}" -eq "0" ]]; then
		return 0
	else
		return 1
	fi
}

is_root=$(check_if_root)

if [[ "${is_root}" -eq "0" ]]; then
	echo "user is root!"
else
	echo "user is not root!"
fi
```

## Accepting Arguments

```sh
print_args(){
	echo "first: ${1}, second: ${2}, third: ${3}"
}

# call the function.
print_args No Starch Press
```


---
# Loops and Loop Controls

## while

In bash, while loops allow you to run a code block ==until some test returns a successful exit status code==

`true` always returns a successful exit code.

```sh
while some_condition; do
	# run commands while the condition is true
done
```

## until

Although while runs so long as the condition succeeds, `until` ==runs so long as it fails==.

```sh
until some_condition; do
# run some commands until the condition is no longer false
done
```

```sh
FILE="output.txt"
touch "${FILE}"

until [[ -s "${FILE}" ]]; do
	echo "$FILE is empty..."
	echo "Checking again in 2 seconds..."
	sleep 2
done

echo "${FILE} appears to have some content in it!"
```

## for

The for loop iterates over a sequence, such as a list of filenames, variables, or even group of values generated by running some command.

```sh
for index in $(seq 1 10); do
	echo "${index}"
done
```

```sh
for ip_address in "$@"; do
echo "Taking some action on IP address ${ip_address}"
done
```


## Case Statements

```sh
case EXPRESSION in
	PATTERN1)
	# do something if the first condition is met
	;;
	PATTERN2)
	# do something if the second condition is met
	;;
esac
```

Let’s take a look at an example case statement that checks whether an IP address is present in a specific private network

```sh
IP_ADDRESS="${1}"

case ${IP_ADDRESS} in
	192.168.*)
	echo "Network is 192.168.x.x"
	;;
	10.0.*)
	echo "Network is 10.0.x.x"
	;;
	*)
	echo "Could not identify the network."
	;;
esac
```


---
# Text Processing and Parsing

## grep

We can even grep for multiple patterns simultaneously. The following backslash pipe (`\|`) acts as an or condition
```sh
grep "35.237.4.214\|13.66.139.0" log.txt
```

Alternatively, you could use multiple grep patterns with the `-e` argument to accomplish the same thing
```sh
grep -e "35.237.4.214" -e "13.66.139.0" log.txt
```

We can also use grep to ==exclude== lines containing a certain pattern using the `-v` argument
```sh
grep -v "35.237.4.214" log.txt
```

To print only the matched pattern, and not the entire line at which the matched pattern was found, use `-o`
```sh
grep -o "35.237.4.214" log.txt
```

## Filtering with `awk` 

The `awk` command is a data processing and extraction Swiss-army knife. 

You can use it to identify and return specific fields from a file. 

To see how it works, take another close look at our log file.

Download [`log.txt`](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch02/log.txt)
```less
13.66.139.0 - - [19/Dec/2020:13:57:26 +0100] "GET /index.php?option=com_phocagallery&view=category&id=1:almhuette-raith&Itemid=53 HTTP/1.1" 200 32653 "-" "Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)" "-"
157.48.153.185 - - [19/Dec/2020:14:08:06 +0100] "GET /apache-log/access.log HTTP/1.1" 200 233 "-" "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36" "-"
157.48.153.185 - - [19/Dec/2020:14:08:08 +0100] "GET /favicon.ico HTTP/1.1" 404 217 "http://www.almhuette-raith.at/apache-log/access.log" "Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36" "-"
216.244.66.230 - - [19/Dec/2020:14:14:26 +0100] "GET /robots.txt HTTP/1.1" 200 304 "-" "Mozilla/5.0 (compatible; DotBot/1.1; http://www.opensiteexplorer.org/dotbot, help@moz.com)" "-"
```
The `$1` represents the first field of every line in the file, where the IP addresses are.
```sh
awk '{print $1}' log.txt
```
By default, `awk` treats spaces or tabs as separators or delimiters.

Using similar syntax, we can print the first and last field simultaneously. 
In this case, `NF` represents the last field
```sh
awk '{print $1,$NF}' log.txt
```

We can also change the default delimiter. 
For example, if we had a CSV file separated by commas, rather than spaces or tabs, we could pass `awk` the `-F` flag to specify the type of delimiter.
```sh
awk -F',' '{print $1}' example_csv.txt
```

We can even use `awk` to print the first 10 lines of some file. 
This emulates the behavior of the head Linux command. 
`NR` represents the total number of records and is built into `awk`
```sh
awk 'NR < 10' log.txt
```

## Editing Streams with `sed`

The `sed` (stream editor) command takes actions on text. 

For example, it can replace the text in a file, modify the text in some command’s output, and even delete selected lines from files.

Let’s use `sed` to replace any mentions of the word Mozilla with the word Godzilla in the `log.txt` file. 

We use its s (substitution) command and g (global) command to make the substitution across the whole file, rather than to just the first occurrence
```sh
sed 's/Mozilla/Godzilla/g' log.txt
```

We could also use `sed` to remove any white-space from the file with the `/ //` syntax, which will replace white-space with nothing, removing it from the output altogether
```sh
sed 's/ //g' log.txt
```

If you need to delete lines of a file, use the d command.
`1d` deletes the first line:
```sh
sed '1d' log.txt
```

To delete the last line of a file, use the dollar sign (`$`), which represents the last line, along with `d`
```sh
sed '$d' log.txt
```

You can also delete multiple lines, such as line 5 and 7
```sh
sed '5,7d' log.txt
```

Lastly, you can `print` specific line ranges, such as lines 2 through 15
```sh
sed -n '2,15 p' log.txt
```


When you pass `sed` the `-i` argument, it will make the changes to the file itself rather than create a modified copy
```sh
sed -i '1d' log.txt
```


# Job Control

We can use the jobs command to see what jobs are currently running
```sh
jobs
```
The output shows the job id

We can migrate the job from the background to the foreground by issuing the `fg` command and the job ID
```sh
fg %1
```

To send this job to the background again in a running state, use the `bg`
command with the job ID
```sh
bg %1
```

Whether you send a job to the background or are running a job in the foreground, the process won’t survive if you close the terminal or log out. 

If you close the terminal, the process will receive a `SIGHUP` signal and terminate.
```sh
nohup ./my_script.sh &
```
The `nohup` command will create a file named `nohup.out` with standard output stream data.
So, make sure you delete this file if you don't want to leave any traces on the disk.

[`systemd`](https://man7.org/linux/man-pages/man1/init.1.html)

