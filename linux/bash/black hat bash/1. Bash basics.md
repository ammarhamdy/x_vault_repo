

# The Shebang Line

Every script should begin with the shebang line, a character
sequence that starts with the hash and exclamation mark symbols
(`#!`), followed by the full path to the script interpreter.

```sh
#!/bin/bash
```

Some Linux distributions place the bash interpreter in different system locations, and this shebang line will attempt to find that location.

You may want to use this shebang line because it is more
portable:
```sh
#!/usr/bin/env bash
```
- `env` is a program that locates and runs another program according to your `PATH` environment variable.
- Using `env bash` means: _"Find the `bash` program in the current user’s `PATH` and run it."_

The shebang line can also take optional arguments to change how the script executes:
```sh
#!/bin/bash -x
```
+ This option will print all commands and their arguments as they are executed to the terminal.
+ It is useful for debugging scripts.

Another example of an optional argument is `-r`:
```sh
#!/bin/bash -r
```
+ This optional argument will create a _restricted bash shell_, which restricts certain potentially dangerous commands that could, for example, navigate to certain directories, change sensitive environment variables..


# Execution

```sh
bash helloworld.sh
```

Because we specified the `bash` command, the script will run using the bash interpreter and won’t require a shebang line. 

Also, if you use the bash command, the script doesn’t have to be set with an executable permission (+x).


# Debugging

```sh
bash -n script.sh
```

This parameter will read the commands in the script but won’t execute them

You can think of it as a dry-run method to test validity of syntax

You can also use the `-x` parameter to turn on verbose mode, which lets you see commands being executed and will help you debug issues as the script executes in real time.

```sh
bash -x script.sh
```


# Streams

Streams are files that act as communication channels between a program and its environment.

When you interact with a program (whether a built-in Linux utility such as ls or `mkdir` or one that you wrote yourself), you’re interacting with one or more streams. 

In bash, there are three standard data streams:
+ Standard Input (`stdin`)
+ Standard Output (`stdout`)
+ Standard Error (`stderr`)


# Redirection Operators

| Operator | Description                                                                   |
| -------- | ----------------------------------------------------------------------------- |
| >        | Redirects stdout to a file                                                    |
| >>       | Redirects stdout to a file by appending it to the existing content            |
| &> or >& | Redirects stdout and stderr to a file                                         |
| &>>      | Redirects stdout and stderr to a file by appending it to the existing content |
| <        | Redirects input to a command                                                  |
| <<       | Called a here document (heredoc), redirects multiple input lines to a command |
| \|       | Redirects output of a command as input to another command                     |

If we wanted to send the standard output stream to one file, and the standard error stream to another:
```sh
$ ls -l / 1> stdout.txt 2> stderr.txt
```

If we wanted to redirect multiple lines to a command:
```sh
cat << EOF
Black Hat Bash
by No Starch Press
EOF
```


# Special Variables Related to Positional Arguments

| Variable    | Description                                                                 |
|-------------|-----------------------------------------------------------------------------|
| $0          | The name of the script file                                                 |
| $1, $2, $3… | Positional arguments                                                        |
| $#          | The number of passed positional arguments                                   |
| $*          | All positional arguments                                                    |
| $@          | All positional arguments, where each argument is individually quoted        |

When a script makes use of `"$*"` with the quotes included, bash will expand arguments into a single word
```sh
$ script.sh "1" "2" "3"
1 2 3
```

When a script makes use of `"$@" ` it will expand arguments into separate words:
```sh
$ script.sh "1" "2" "3"
1
2
3
```


# Exit Status Codes

Status codes fall in the `0–255` range, where `0` means success, `1` means failure, `126` means that the command was found but is not executable, and `127` means the command was not found.

Print status code for the last executed command:
```sh
echo $?
```

Setting a Script’s Exit Codes
```sh
exit 223
```

