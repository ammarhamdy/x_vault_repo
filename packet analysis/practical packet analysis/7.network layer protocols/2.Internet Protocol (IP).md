

Layer 3 is responsible for addresses used in inter-network communication. 

A few protocols can do this, but the most common is the Internet Protocol (IP), which currently has two versions in use—IP version 4 and IP version 6.


# Internet Protocol Version 4 (IPv4)

IPv4 addresses are **==32-bit==** assigned numbers used to uniquely identify devices connected to a network. It’s a bit much to expect someone to remember a sequence of ones and zeros that is 32 characters long, so IP addresses are written in dotted-quad (or dotted-decimal) notation.

An IP address consists of two parts: a network portion and a host portion.

IP addresses and netmasks are commonly written in **==Classless Inter Domain Routing (`CIDR`)==** notation.
In this form, an IP address is written in full, followed by a forward slash (`/`) and the number of bits that represent the network portion of the IP address.

For example, an IP address of `10.10.1.22` and a netmask of `255.255.0.0` would be written in `CIDR` notation as `10.10.1.22/16`.


# IPv4 Packet Structure

![[Pasted image 20250127072135.png]]

![[Pasted image 20250127072357.png]]

**Version** 
	The version of IP being used.
**Header Length** 
	The length of the IP header.
**Type of Service** 
	A precedence flag and type of service flag, which are used by routers to **==prioritize==** traffic.
**Total Length** 
	The length of the IP header and the data included in the packet.
**Identification** 
	A unique identification number used to identify a packet or sequence of fragmented packets.
**Flags** 
	Used to identify whether a packet is part of a sequence of fragmented packets.
**Fragment Offset** 
	==If a packet is a fragment, the value of this field is used to reassemble the packets in the correct order.==
**Time to Live** 
	Defines the lifetime of the packet, measured in hops or seconds through routers.
**Protocol** 
	Identifies the transport layer header that encapsulates the IPv4 header.
**Header Checksum**
	An error-detection mechanism used to verify that the contents of the IP header are not damaged or corrupted.
**Source IP Address** 
	The IP address of the host that sent the packet. 
**Destination IP Address** 
	The IP address of the packet’s destination. 
**Options** 
	Reserved for additional IP options. 
	It includes options for source routing and timestamps.
**Data** 
	The actual data being transmitted with IP.


## Time to Live
A TTL is defined when a packet is created and generally is decremented by 1 every time the packet is forwarded by a router. 
For example, if a packet has a TTL of 2, the first router it reaches will decrement the TTL to 1 and forward it to the second router. This router will then decrement the TTL to zero.

An infinite loop can cause all sorts of issues, but it typically results in the crash of a program or an entire operating system.

The packets would keep looping between routers. 
As the number of looping packets increased, the available bandwidth on the network would deplete until a denial of service condition occurred.

To prevent this, TTL was created.

Let’s look at an example of this in Wireshark. 
The file `ip_ttl_source.pcapng` contains two ICMP packets.

![[Pasted image 20250127073721.png]]

The primary purpose of an ICMP ping is to test communication between devices. 
Data is sent from one host to another as a request, and the receiving host should send that data back as a reply.

![[Pasted image 20250127073941.png]]


Now open the file `ip_ttl_dest.pcapng`. 
In this file, the data was captured at the destination host, `192.168.0.128`.
Expand the IP header of the first packet in this capture to examine its TTL value.
You should immediately notice that the TTL value is 127, 1 less than the original TTL of 128.


## IP Fragmentation

Packet fragmentation is a feature of IP that permits reliable delivery of data cross varying types of networks by splitting a data stream into smaller fragments.

The fragmentation of a packet is based on the **==maximum transmission unit (`MTU`)==** size of the layer 2 data link protocol in use and the configuration of the devices using this layer 2 protocol. 

In most cases, the layer 2 data link protocol in use is Ethernet. 
Ethernet has a default MTU of 1,500, which means that the maximum packet size that can be transmitted over an Ethernet network is 1,500 bytes (not including the 14-byte Ethernet header itself).

**MTU**
Although there are standard MTU settings, the MTU of a device can be reconfigured manually in most cases. 
An MTU setting is assigned on a per-interface basis and can be modified on Windows and Linux systems, as well as on the interfaces of managed routers.

When a device prepares to transmit an IP packet, it determines whether it must fragment the packet by comparing the packet’s data size to the MTU of the network interface from which the packet will be transmitted.
If the data size is greater than the MTU, the packet will be fragmented. 

**Fragmenting a packet involves the following steps:**
1. The device splits the data into the number of packets required for successful data transmission. 
2. The ==Total Length== field of each IP header is set to the segment size of each fragment.
3. The More fragments flag is set to 1 on all packets in the data stream, except for the last one.
4. The Fragment offset field is set in the IP header of the fragments.
5. The packets are transmitted.

The file `ip_frag_source.pcapng` was taken from a computer with the address `10.10.0.3`, transmitting a ping request to a device with the address `192.168.0.128`.
Notice that the Info column of the Packet List pane lists two fragmented IP packets, followed by the ICMP (ping) request.

In the first packet, the More fragments flag is set, indicating that the receiving device should expect to receive another packet in this sequence. 
The Fragment offset is set to `0`, indicating that this packet is the first in a series of fragments.

![[Pasted image 20250127103132.png]]

The IP header of the second packet also has the More fragments flag set, but in this case, the Fragment offset value is `1480` . 
==This is indicative of the **1,500**-byte MTU, minus **20** bytes for the IP header==.

The third packet does not have the More fragments flag set, which marks it as the last fragment in the data stream, and the Fragment offset is set to `2960`, the result of 
```
1480 + (1500 – 20)
```
==These fragments can all be identified as part of the same series of data because they have the same values in the **Identification field** of the IP header.==



# Internet Protocol Version 6 (IPv6)

The maximum IPv4 addressable space was limited to just south of 4.3 billion addresses.

The actual amount of addressable space shrinks even further when you subtract ranges reserved for special uses such as testing, broadcast traffic, and `RFC1918` internal addresses.

Thus, the IPv6 specification was created, with its first version released in `1998` as `RFC 2460`. 
This version provided several performance enhancements, including a much larger address space.

# IPv6 Addresses

IPv4 addresses were limited to 32 bits, a length that provided an addressable space measured in the billions. 
IPv6 addresses are **==128 bit==**, providing an addressable space measured in `undecillions`.
```
2**128
```

Since IPv6 addresses are 128 bits, they are unwieldy to manage in binary form. 
Most of the time, an IPv6 address is written in eight groups of 2 bytes in hexadecimal notation, with each group separated by a colon.
```
1111:aaaa:2222:bbbb:3333:cccc:4444:dddd
```

You can collapse the grouping containing the zeroes completely so it isn’t visible, like this:
```
1111:0000:2222:0000:3333:4444:5555:6666
1111::2222:0000:3333:4444:5555:6666
```
==**However, you can only collapse a single group of zeroes**==

**==Leading zeroes can be dropped==**
```
1111:0000:2222:0333:0044:0005:ffff:ffff
1111::2222:333:44:5:ffff:ffff
```


An IPv6 address has a **==network portion==** and a **==host portion==**, often called a **==network prefix==** and **==interface identifier==**, respectively. 
The distribution of these fields varies depending on the classification of the IPv6 communication. 
IPv6 traffic is broken down into three classifications: ==unicast==, ==multicast==, or ==anycast==. 
In most cases, you’ll probably be working with link-local unicast traffic, which is communication from one device to another inside a network. 

The format of a link-local unicast IPv6 address is:
```
fe80:0000:0000:0000:7a31:c1ff:fecb:b256
```
**Prefix:** `fe80`
**Padding:** `0000:0000:0000`
**Interface Identifier:** `7a31:c1ff:fecb:b256`

Link-local addresses are used when communication is intended for another device within the same network. 
A link-local address can be identified by having its most significant 10 bits set to `1111111010` and the next 54 bits set to all zeroes. 
Thus, you can spot a link-local address when the first half is `fe80:0000:0000:0000`.

The second half of a link-local IPv6 address is the interface ID portion, which uniquely identifies a network interface on an endpoint host. 
On Ethernet networks, this can be based on the MAC address of the interface. 
However, a MAC address is only 48 bits. 
To fill up the entire 64-bit space, the MAC address is cut in half, and the value `0xfffe` is added between each half as padding to create a unique identifier.
Lastly, the seventh bit of the first byte is inverted.

**Consider the interface ID:**
The original MAC address for the device represented by this ID was `78:31:c1:cb:b2:56`.
The bytes `0xfffe` were added in the middle, and flipping the seventh bit of the first byte changed the 8 to an a.
```
7a31:c1ff:fecb:b256
```
![[Screenshot from 2025-01-27 11-22-56.png]]


**CIDR**
IPv6 addresses can be represented with CIDR notation just like IPv4 addresses.
In this example, 64 bits of addressable space are represented with a link-local address:
```
fe80:0000:0000:0000:/64
```


The composition of an IPv6 address changes when it is used with global unicast traffic that is routed over the public internet.
When used in this manner, a global unicast is identified by having its first 3 bits set to `001`, followed by a **==45-bit global routing prefix==**. 
The global routing prefix, which is assigned to organizations by the ==**Internet Assigned Numbers Authority (`IANA`)**==, ==is used to uniquely identify an organization’s IP space==.

The next 16 bits are the subnet ID, which can be used for hierarchical addressing, similar to the netmask portion of an IPv4 address. 
The final 64 bits are used for the interface ID, just as with link-local unicast addresses. 
The routing prefix and subnet ID can vary in size.
```
2001:4860:4860:0000:7a31:c1ff:fecb:b256
```

**The parts of an IPv6 global unicast address:**
+ Network Prefix: `2001:4860:4860:0000`
	+ Routing Prefix: `2001:4860:4860`
	+ Subnet ID: `:0000`
+ Interface Identifier: `7a31:c1ff:fecb:b256`

IPv6 provides a lot more efficiency than IPv4 in terms of routing packets to their destination and making effective use of address space. 
This efficiency is due to the larger range of addresses available and the use of link-local and global addressing along with unique host identifiers.

If you need to specify an IPv6 address, some applications, such as browsers or command line utilities, require you to place square brackets around the address, like this: `[1111::2222:333:44:5:ffff]`.


## IPv6 Packet Structure

The structure of the IPv6 header has grown to support more features, but it was also designed to be easier to parse. 

Instead of being variable in size with a header length field that needs to be checked to parse the header, headers are now a **==fixed 40 bytes==**. 

Additional options are provided via extension headers. 

The benefit is that most routers only need to process the 40-byte header to forward the packet along.

![[Pasted image 20250127131304.png]]

**Version**:
	The version of IP being used

**Traffic Class**:
	Used to ==prioritize== certain classes of traffic.

**Flow Label**:
	Used by a source to label a set of packets belonging to the same flow. 
	This field is typically used for quality of service (QoS) management and to ensure packets that are part of the same flow take the same path. 

**Payload Length**: 
	The length of the data payload following the IPv6 header. 

**Next Header**: 
	Identifies the layer 4 header that encapsulates the IPv6 header.
	 This field replaces the Protocol field in IPv4. 
	
**Hop Limit**: 
	Defines the lifetime of the packet, measured in hops through routers. 
	This field replaces the TTL field in IPv4. 
	
**Source IP Address**: 
	The IP address of the host that sent the packet. 
	
**Destination IP Address**: 
	The IP address of the packet’s destination.


Let’s compare an IPv4 and an IPv6 packet to examine a few of the differences by looking at `http_ip4and6.pcapng`.

Packets 1 through 10 represent the IPv4 stream (stream 0), and packets 11 through 20 represent the IPv6 stream (stream 1). 
You can filter for each of these streams from the Conversations window or by entering `tcp.stream == 0` or `tcp.stream == 1` in the filter bar


## Comparison 

## Size
The IPv4 packet is **==74 bytes==** with a ==60-byte== total length, which includes both the IPv4 header and payload and a ==14-byte== Ethernet header.

The IPv6 packet is **==96 bytes==** with a ==40-byte== IPv6 payload and a separate ==40-byte== IPv6 header along with the ==14-byte== Ethernet header.

The IPv6 header is 40 bytes, double the IPv4 header’s 20 bytes, to accommodate the larger address size.

## Protocol field
IPv4 identifies the protocol with the Protocol field, whereas IPv6 identifies it with the Next header field.

## Time to live - Hop limit
IPv4 has a TTL field , whereas IPv6 accomplishes the same functionality using the Hop limit field.

## checksum
IPv4 includes a header checksum value, while IPv6 does not.


## fragmentation
The IPv4 packet is not fragmented, but it still includes values for those options.

The IPv6 header doesn’t contain this information because, if fragmentation were required, it would be implemented in an extension header.


# Neighbor [Solicitation](https://translate.google.com/?sl=en&tl=ar&text=Solicitation&op=translate) and ARP

IPv6 doesn’t support broadcast traffic because broadcast is viewed as an inefficient mechanism for transmission.

Because there is no broadcast, ARP **==can’t==** be used for hosts to find each other on a network. So, how do IPv6 devices find each other?

The answer lies with a new feature called neighbor solicitation, a function of ==Neighbor Discovery Protocol== (`NDP`), which utilizes `ICMPv6`.

To accomplish this task, `ICMPv6` uses multicast, a type of communication in which only hosts that subscribe to a data stream will receive and process it. 
Multicast traffic can be identified quickly because it has its own reserved IP space (`ff00::/8`).

Although the address resolution process relies on a different protocol, it still uses a very simple request/response workflow.

**For example** 
Let’s consider a scenario in which a host with the IPv6 address `2001:db8:1:2::1003` wants to communicate with another host identified by the address `2001:db8:1:2::1000`.

![[Pasted image 20250127135806.png]]
You can see this process in action in the capture file `icmpv6_neighbor_solicitation.pcapng`.

`2001:db8:1:2::1003` wants to communicate with `2001:db8:1:2::1000`


# IPv6 Fragmentation

In IPv6, fragmentation is used less, so the options supporting it are not included in the IPv6 header. 

A device transmitting IPv6 packets is expected to perform a process called MTU discovery to determine the maximum size of packets it can send before actually sending them. 

In the event that a router receives a packet that is too large for the MTU on the network it is forwarding to, it will drop the packet and return an ICMPv6 Packet Too Big (type 2) message to the originating host.

Upon receipt, the originating host will attempt to resend the packet with a smaller MTU, if such action is supported by the upper-layer protocol. 

This process will repeat until a small enough MTU is reached or until the payload can be fragmented no more.

==A router will never be responsible for fragmenting packets on its own; the source device is responsible for determining an appropriate MTU for the transmission path and fragmenting appropriately==.

![[Pasted image 20250127141929.png]]


==If the **upper-layer** protocol being used in conjunction with IPv6 can’t limit the size of the packet payload, then fragmentation must still be used==.

A fragmentation extension header can be added to the IPv6 packet to support this scenario.

You will find a sample capture showing IPv6 fragmentation in the file named `ipv6_fragments.pcapng`

Because the receiving device has a smaller MTU than the sending device, there are two fragmented packets to represent each `ICMPv6` echo request and reply in the capture file.

![[Pasted image 20250127143327.png]]

![[Pasted image 20250127143421.png]]

The `8-byte` extension header contains all the same fragmentation properties that are found in an IPv4 packet, such as a _Fragment offset_ `2`, _More Fragments flag_ `3`, and _Identification field_ `4`.

Instead of being present in every packet, ==it is **only** added to the end of packets requiring fragmentation==. 

This more efficient process still allows the receiving system to reassemble the fragments appropriately. 

Additionally, if this extension header is present, the _Next header field_ will point to the extension header rather than the encapsulating protocol `1`.



# IPv6 Transitional Protocols

Several protocols allow IPv6 communication to be tunneled across networks that support only IPv4 communication.

In this respect, tunneling means that IPv6 communication is encapsulated inside of IPv4 communications just as other protocols may be encapsulated.

Encapsulation is usually done in one of three ways:

**Router to Router**:
	Uses a tunnel to encapsulate IPv6 traffic from the transmitting and receiving hosts on their networks over an IPv4 network. 
	This method allows entire networks to communicate in IPv6 over intermediary IPv4 links.

 **Host to Router**: 
	 Uses encapsulation at the router level to transmit traffic from an IPv6 ==host== over an IPv4 network. 
	 This method allows an individual host to communicate in IPv6 to an IPv6 network when the host resides on an IPv4-only network. 

**Host to Host**:
	Uses a tunnel between two endpoints to encapsulate IPv6 traffic between IPv4- or IPv6-capable hosts. 
	This method allows IPv6 endpoints to communicate directly across an IPv4 network.

## The following are a few common protocols used with ipv6:

**6to4**: 
	Also known as IPv6 over IPv4, this transitional protocol allows IPv6 packets to be transmitted across an IPv4 network. 
	This protocol supports relays and routers to provide router-to-router, host-to-router, and host-to-host IPv6 communication. 

**Teredo**: 
	This protocol, used for IPv6 unicast communications over an IPv4 network using NAT (network address translation), works by sending IPv6 packets over IPv4 encapsulated in the UDP transport protocol. 

**ISATAP**: 
	This intrasite protocol allows communication between IPv4- and IPv6-only devices within a network in a host-to-host manner.