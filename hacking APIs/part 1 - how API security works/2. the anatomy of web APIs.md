

## How Web APIs Work

Like web applications, web APIs rely on HTTP to facilitate a client/server relationship between the host of the API (the provider) and the system or person making an API request (the consumer).

An API consumer can request resources from an API endpoint, which is a URL for interacting with part of the API.

Each of the following examples is a different API endpoint:
* `https://example.com/api/v3/users/`
* `https://example.com/api/v3/customers/`
* `https://example.com/api/updated_on/`
* `https://example.com/api/state/1/`

**Resources are the data being requested.** 

**A singleton resource** is a unique object, such as `/api/user/{user_id}`. 

**A collection** is a group of resources, such as `/api/profiles/users`. 

**A sub-collection** refers to a collection within a particular
resource. 

For example, `/api/user/{user_id}/settings` is the endpoint to access the settings sub-collection of a specific (singleton) user.

### **API gateway**

When a consumer requests a resource from a provider, the request passes through **an API gateway**, which is an API management component that acts as an entry point to a web application.

users can access an application’s services using a [plethora](https://translate.google.com/?sl=en&tl=ar&text=plethora&op=translate) of devices, which are all filtered through an API gateway. 

The API gateway then distributes the requests to whichever micro-service is needed to fulfill each request.

The API gateway 
+ filters bad requests, 
+ monitors incoming traffic, 
+ and routes each request to the proper service or micro-service.

The API gateway can ==also handle security controls== such as
+ authentication, 
+ authorization,
+ encryption in transit using SSL, 
+ rate limiting, 
+ and load balancing.


### Micro-service

A microservice is a modular piece of a web app that handles a specific function. 

Microservices use APIs to transfer data and trigger actions. 

For example, a web application with a payment gateway may have several different features on a single web page: a billing feature, a feature that logs customer account information, and one that emails receipts upon purchase.

The application’s back-end design could be monolithic, meaning all the services exist within a single application, or it could have a microservice architecture, where each service functions as its own standalone application.


## CRUD

The [acronym](https://translate.google.com/?sl=en&tl=ar&text=acronym&op=translate) CRUD, which stands for **Create**, **Read**, **Update**, **Delete**, describes the primary actions and methods used to interact with APIs.

**Create** is the process of making new records, accomplished through a POST request. 

**Read** is data retrieval, done through a GET request. 

**Update** is how currently existing records are modified without being overwritten and is accomplished with POST or PUT requests. 

**Delete** is the process of erasing records, which can be done with POST or DELETE.

By convention, curly brackets mean that a given variable is necessary within the path parameters. 

The `{client_id}` variable must be replaced with an actual client’s ID, and the `{access_token}` variable must be replaced with
your own access token.

Tokens are what API providers use to identify and authorize requests to approved API consumers. 

Other API documentation might use a colon or square brackets to signify a variable for example, 
`/api/v2/:customers/ or /api/:collection/:client_id`.



## Standard Web API Types

This section describes the two primary API types we’ll focus on
**`RESTful`** APIs and **`GraphQL`**.

### RESTful APIs

==Representational State Transfer== (REST) is a set of architectural constraints for applications that communicate using HTTP methods. 

APIs that use REST constraints are called RESTful (or just REST) APIs.

REST was designed to improve upon many of the inefficiencies of other older APIs, such as Simple Object Access Protocol (SOAP).

For example, it relies entirely on the use of HTTP, which makes it much more approachable to end users.

REST APIs primarily use the HTTP methods GET, POST, PUT, and DELETE to accomplish CRUD.

RESTful design depends on **six** constraints. 

These constraints are **“shoulds”** instead of “**musts**,” reflecting the fact that REST is essentially a set of guidelines for an HTTP resource-based architecture:

1. **Uniform interface:** 
	+ REST APIs should have a uniform interface. 
	+ In other words, the requesting client device should not matter; a mobile device, an IoT (internet of things) device, and a laptop must all be able to access a server in the same way.

2. **Client/server:** 
	+ REST APIs should have a client/server architecture.
	+ Clients are the consumers requesting information, and servers are the providers of that information.

3. **Stateless:** 
	+ REST APIs should not require stateful communications.
	+ ==REST APIs do not maintain state during communication;== it is as though each request is the first one received by the server. 
	+ The consumer will therefore need to supply everything the provider will need in order to act upon the request.
	+ This has the benefit of saving the provider from having to remember the consumer from one request to another.
	+ **==Consumers often provide tokens to create a state-like experience.==**

4. **Cache-able:**
	+ The response from the REST API provider should indicate whether the response is cache-able. 
	+ Caching is a method of increasing request throughput by storing commonly requested data on the client side or in a server cache. 
	+ When a request is made, the client will first check its local storage for the requested information. 
	+ If it doesn’t find the information, it passes the request to the server, which checks its local storage for the requested information. 
	+ If the data is not there either, the request could be passed to other servers, such as database servers, where the data can be retrieved. 
	+ As you might imagine, if the data is stored on the client, the client can immediately retrieve the requested data at little to no processing cost to the server. 
	+ This also applies if the server has cached a request. 
	+ The further down the chain a request has to go to retrieve data, the higher the resource cost and the longer it takes.
	+ Making REST APIs cache-able by default is a way to improve overall REST performance and scalability by decreasing response times and server processing power.
	+ ==APIs usually manage caching with the use of **headers** that explain when the requested information will expire from the cache.==

5. **Layered system:** 
	+ The client should be able to request data from an end point without knowing about the underlying server architecture.

6. **Code on demand (optional):** Allows for code to be sent to the client for execution.


==**REST is a style rather than a protocol, so each RESTful API may be different.** ==

It may have methods enabled beyond CRUD, its own sets of authentication requirements, subdomains instead of paths for endpoints, different rate-limit requirements, and so on.


Shows a fairly typical REST API GET request used to find out
how many pillows are in a store’s inventory. 

A sample RESTful API request:
```
GET /api/v3/inventory/item/pillow HTTP/1.1
HOST: rest-shop.com
User-Agent: Mozilla/5.0
Accept: application/json
```
This REST API request is just an HTTP GET request to the specified
URL.

A sample RESTful API response:
```
HTTP/1.1 200 OK
Server: RESTfulServer/0.1
Cache-Control: no-store
Content-Type: application/json
{
"item": {
"id": "00101",
"name": "pillow",
"count": 25
"price": {
"currency": "USD",
"value": "19.99"
}
},
}
```


### headers

REST APIs have some common headers you should become familiar with. 

These are identical to HTTP headers but are more commonly seen in REST API requests than in other API types, so they can help you identify REST APIs.

#### Common REST API headers you will come across:


**Authorization**

Authorization headers are used to pass a token or credentials to the API provider. 

The format of these headers is:
```
Authorization: <type> <token/credentials>
```
For example, take a look at the following authorization header:
```
Authorization: Bearer Ab4dtok3n
```
There are different authorization types. 
**Basic** uses `base64-encoded credentials`. 
**Bearer** uses an API token. 
Finally,
`AWS-HMAC-SHA256` is an `AWS` authorization type that uses an access key and a secret key.


**Content Type**

**Content-Type headers are used to indicate the type of media being transferred.** 

These headers differ from **Accept** headers, which state the media
type you want to receive; 

==Content-Type headers describe the media you’re sending.==

Here are some common Content-Type headers for REST APIs:
+ `application/json`  Used to specify JavaScript Object Notation (JSON) as a media type.
+ `application/xml`  Used to specify XML as a media type.
+ `application/x-www-form-urlencoded` A format in which the values being sent are encoded and separated by an ampersand (&), and an equal sign (=) is used between key/value pairs.


**Middleware (X) Headers**

`X-<anything>` headers are known as middleware headers and can serve all sorts of purposes. They are fairly common outside of API requests as well.

`X-Response-Time` can be used as an API response to indicate how long a response took to process.

`X-API-Key` can be used as an authorization header for API keys. X-Powered-By can be used to provide additional information about back-end services. 

`X-Rate-Limit` can be used to tell the consumer how many requests they can make within a given time frame. 

`X-RateLimit-` Remaining can tell a consumer how many requests remain before they violate rate-limit enforcement.

`X-<anything>` middleware headers can provide a lot of useful information to API consumers and hackers alike.


## ENCODING DATA

HTTP requests use encoding as a method to ensure that communications are handled properly. 

Various characters that can be problematic for the technologies used by the server are known as ==**bad characters**==.

One way of handling bad characters is to use an encoding scheme
that formats the message in such a way as to remove them.

Common encoding schemes include
+ Unicode encoding, 
+ HTML encoding, 
+ URL encoding, 
+ and `base64` encoding. 
+ XML typically uses one of two forms of ==**Unicode encoding**==:
	+ `UTF-8` 
	+ or `UTF-16`

When the string “hAPI hacker” is encoded in `UTF-8`, it becomes the following:
```
\x68\x41\x50\x49\x20\x68\x61\x63\x6B\x65\x72
```

Here is the `UTF-16` version of the string:
```
\u{68}\u{41}\u{50}\u{49}\u{20}\u{68}\u{61}\u{63}\u{6b}\u{65}\u{72}
```

Finally, here is the `base64-encoded` version:
```
aEFQSSBoYWNrZXI=
```

==Recognizing these encoding schemes will be useful as you begin examining requests and responses and encounter encoded data.==




## GraphQL

Short for ==**Graph Query Language**==, GraphQL ==is a specification for APIs that allow clients to define the structure of the data they want to request from he server==.

==GraphQL is RESTful==, as it follows the six constraints of REST
APIs. 

However, GraphQL also takes the approach of being query-centric, because it is structured to function similarly to a database query language like Structured Query Language (SQL).

As you might gather from the specification’s name, GraphQL stores the resources in a graph data structure. 

To access a GraphQL API, you’ll typically access the URL where it is hosted and submit an authorized request that contains query parameters as the body of a POST request, similar to the following:

```
query {
	users {
		username
		id
		email
	}
}
```

In the right context, this query would provide you with the usernames, IDs, and emails of the requested resources.

```
{
	"data": {
		"users": {
			"username": "hapi_hacker",
			"id": 1111,
			"email": "hapihacker@email.com"
		}
	}
}
```

GraphQL improves on typical REST APIs in several ways. 

Since REST APIs are resource based, there will likely be instances when a consumer needs to make several requests in order to get all the data they need. 

On the other hand, if a consumer only needs a specific value from
the API provider, the consumer will need to filter out the excess data. 

With GraphQL, a consumer can use a single request to get the exact data they want. 

That’s because, unlike REST APIs, where clients receive whatever
data the server is programmed to return from an endpoint, including the data they don’t need, ==**GraphQL APIs let clients request specific fields from a resource.**==

**==GraphQL also uses HTTP==**, but it typically depends on a single entry
point (URL) using the POST method. 

In a GraphQL request, the body of the POST request is what the provider processes.

**For example**
GraphQL request:
```
POST /graphql HTTP/1.1
HOST: graphql-shop.com
Authorization: Bearer ab4dt0k3n
{query {
	inventory (item:"Graphics Card", id: 00101) {
	name
		fields{
			price
			quantity
		} 
	} 
}}
```

GraphQL response:
```
HTTP/1.1 200 OK
Content-Type: application/json
Server: GraphqlServer

{
"data": {
	"inventory": { "name": "Graphics Card",
	"fields":[
		{"price":"999.99""quantity": 25 } 
	] 
	} 
	}
}
```


As you can see, a query payload in the body specifies the information needed. 

The GraphQL request body begins with the `query` operation,
which is the equivalent of a `GET` request and used to obtain information from the API. 

The GraphQL node we are querying for, "inventory" , is
also known as the root query type.

GraphQL still functions using CRUD, which may sound confusing at
first since it relies on POST requests.

However, ==GraphQL uses three operations within the POST request to interact with GraphQL APIs==: query, mutation, and subscription.

**Query** is an operation to retrieve data (read).

**Mutation** is an operation used to submit and write data (create, update, and delete). 

**Subscription** is an operation used to send data (read) when an event occurs. 
Subscription is a way for GraphQL clients to ==listen== to live updates
from the server.

GraphQL uses `schemas`, ==which are collections of the data that can be queried with the given service.==

Having access to the GraphQL [schema](https://translate.google.com/?sl=en&tl=ar&text=schema&op=translate) is similar to having access to a REST API collection. 

A GraphQL schema will provide you with the information you’ll need in order to query the API.

You can interact with GraphQL using a browser if there is a GraphQL IDE, like `GraphiQL`.
Otherwise, you’ll need a GraphQL client such as 
`Postman`, 
`Apollo-Client`, 
`GraphQL-Request`, 
`GraphQL-CLI`, 
or `GraphQL-Compose`



## SOAP: AN ACTION-ORIENTED API FORMAT

**==Simple Object Access Protocol (SOAP)==**
==is a type of action-oriented API that relies on XML.==

SOAP is one of the older web APIs, originally released as XML-
RPC back in the late 1990s, ==so we won’t cover it==

Although SOAP works over HTTP, SMTP, TCP, and UDP, it was primarily designed for use over HTTP. 

When SOAP is used over HTTP, the requests are all made using HTTP POST.



## REST API Specifications

The variety of REST APIs has left room for other tools and standardizations to fill in some of the gaps. 

API specifications, or description languages, are frameworks that help organizations design their APIs, automatically create consistent human-readable documentation.

==Without specifications, there would be little to no consistency
between APIs.==

Consumers would have to learn how each API’s documentation was formatted and adjust their application to interact with each API.

You can think of specifications as the home electric
sockets of APIs. 
Instead of having a unique electric socket for every home appliance, the use of a single consistent format throughout a home allows you to buy a toaster and plug it into a socket on any wall without any hassle.
![[Pasted image 20250104120014.png]]


### Open-API Specification 3.0 (OAS)

Open-API Specification 3.0 (OAS), previously known as Swagger, is one of the leading specifications for RESTful APIs. 

OAS helps ==organize== and ==manage== APIs by allowing developers to describe endpoints, resources, operations, and authentication and authorization requirements. 

They can then create human- and machine-readable API documentation, formatted as JSON or YAML.


### The RESTful API Modeling Language (RAML)

The RESTful API Modeling Language (RAML) is another way to consistently generate API documentation. 

RAML is an open specification that works exclusively with YAML for document formatting. 

Similar to OAS, RAML was designed to document, design, build, and test REST APIs. 

For more information about RAML, check out the raml-spec GitHub repo:
(https://github.com/raml-org/raml-spec).

==In later, we will use an API client called Postman to import specifications==




## API Data Interchange Formats

==APIs use several formats to facilitate the exchange of data. ==

==Additionally, specifications use these formats to document APIs.==

Three common formats: **JSON**, **XML**, and **YAML**.


### JSON

JavaScript Object Notation (JSON) is the primary data interchange format.

JSON represents objects as key/value pairs separated by commas,
within a pair of curly brackets.

### XML

The Extensible Markup Language (XML) format has been around for a while, and you’ll probably recognize it. 

XML is characterized by the descriptive tags it uses to wrap data. Although REST APIs can use XML, it is most commonly associated with SOAP APIs. 

SOAP APIs can only use XML as the data interchange.


### YAML

Another lightweight form of data exchange used in APIs, YAML is a recursive acronym that stands for YAML ==**Ain’t Markup Language.**== 

It was created as a more human- and computer-readable format for data exchange.

The value may be any of the YAML data types, which include numbers, strings, Booleans, null values, and sequences.

```
# To-Do List
tasks:
  - id: 1
    title: "Buy groceries"
    description: "Milk, bread, eggs, and coffee"
    priority: "high"
    deadline: "2025-01-06"
    completed: false
  - id: 2
    title: "Finish project report"
    description: "Prepare the final draft for submission"
    priority: "medium"
    deadline: "2025-01-07"
    completed: false
  - id: 3
    title: "Call Mom"
    description: "Catch up and discuss weekend plans"
    priority: "low"
    deadline: "2025-01-05"
    completed: true
settings:
  notify_before_deadline: true
  default_priority: "medium"
metadata:
  created_by: "John Doe"
  created_at: "2025-01-04"
  version: 1.0
```


instead of with curly brackets. Also, quotes around strings are optional.

Additionally, URLs don’t need to be encoded with backslashes. Finally, YAML uses indentation instead of curly brackets to represent nesting and allows for comments beginning with `#`.

visit https://yaml.org/





## API Authentication


APIs may allow public access to consumers without authentication, but when an API allows access to proprietary or sensitive data, it will use some form of authentication and authorization. 

**An API’s ==authentication== process** should validate that users are who they claim to be, 
and **the ==authorization== process** should grant them the ability to access the data they are allowed to access.

The consumer must send some kind of information to the provider when making a request, and the provider must link that information to a user before granting or denying access to a resource.


### Authentication

==Authentication is the process of proving and **verifying an identity**==.

In a web application, authentication is the way you prove to the web server that you are a valid user of said web app. 

Typically, this is done through the use of credentials, which consist of a unique ID (such as a **username** or **email**) and **password**.

**Credentials:**

After a client sends credentials, the web server compares what was sent to the credentials it has stored. 

If the credentials provided match the credentials stored, the web server will create a user session and issue a cookie to the client.

When the session ends between the web app and user, the web server will destroy the session and remove the associated client cookies.


==REST and GraphQL APIs are stateless, so when a consumer authenticates to these APIs, no session is created between the client and server. 
Instead, the API consumer must prove their identity within every request sent to the API provider’s web server.==


#### Basic Authentication

The simplest form of API authentication is HTTP basic authentication, in which the consumer includes their username and password in a header or the body of a request. 

The API could either pass the username and password to the provider in plain text, like `username:password`, or it could encode the credentials using something like `base64` to save space

Encoding is not encryption, and if **`base64-encoded`** data is captured, it can easily be decoded. 

For example, you can use the Linux command line to `base64-encode` username:password and then decode the encoded result:

```
$ echo "username:password"|base64
dXNlcm5hbWU6cGFzc3dvcmQK
$ echo "dXNlcm5hbWU6cGFzc3dvcmQK"|base64 -d
username:password
```

It is common for an API provider to instead use basic authentication once, for the first request, and then issue an API key or some other token for all other requests.


#### API Keys

API keys are unique strings that API providers generate and grant to authorize access for approved consumers. 

Once an API consumer has a key, they can include it in requests whenever specified by the provider. 

The provider will typically require that the consumer pass the key in query string parameters, request headers, body data, or as a cookie when they make a request.

API key included in the query string of the following URL:
```
/api/v1/users?apikey=ju574n3x4mpl34p1k3y
```

The following is an API key included as a header:
```
"API-Secret": "17813fg8-46a7-5006-e235-45be7e9f2345
```

Finally, here is an API key passed in as a cookie:
```
Cookie: API-Key= 4n07h3r4p1k3y
```

The process of acquiring an API key depends on the provider.

API keys can be more secure than basic authentication for several reasons. 

When keys are sufficiently long, complex, and randomly generated, they can be exceedingly difficult for an attacker to guess or brute-force.

Additionally, providers can set expiration dates to limit the length of time for which the keys are valid.

==However, API keys have several associated risks==.

Since each API provider may have their own system
for generating API keys, you’ll find instances in which the API key is generated based on user data. 

In these cases, API hackers may guess or forge API keys by learning about the API consumers. 

API keys may also be exposed to the internet in online epositories, left in code comments, intercepted when transferred over un-encrypted connections, or stolen through phishing.


#### JSON Web Tokens

A JSON Web Token (JWT) is a type of token commonly used in API token-based authentication. 

It’s used like this: The API consumer authenticates to the API provider with a username and password. 

The provider generates a JWT and sends it back to the consumer. 

The consumer adds the provided JWT to the Authorization header in all API requests.

JWTs consist of three parts, all of which are `base64-encoded` and separated by periods`:` the header, the payload, and the signature. 

The header includes information about the algorithm used to sign the payload. 
The payload is the data included within the token, such as a username, time-stamp, and issuer. 

The signature is the encoded and encrypted message used to validate the token.

The JWT secret key may also be stolen or guessed by brute force.


#### HMAC

A hash-based message authentication code (HMAC) is the primary API authentication method used by Amazon Web Services (AWS). 

When using HMAC, the provider creates a secret key and shares it with consumer.
When a consumer interacts with the API, an HMAC hash function is applied to the consumer’s API request data and secret key. 
The resulting hash (also called a message digest) is added to the request and sent to the provider. 
The provider calculates the HMAC, just as the consumer did, by running the message and key through the hash function, and then compares the output hash value to the value provided by the client. 
If the provider’s hash value matches the consumer’s hash value, the consumer is authorized to make the request.


#### OAuth 2.0

OAuth 2.0, or just OAuth, ==**is an authorization standard that allows different services to access each other’s data**==, often using APIs to facilitate the ==**service-to-service communications**==.

Let’s say you want to automatically share your Twitter tweets on
LinkedIn. 
In OAuth’s model, we would consider Twitter to be the service
provider and LinkedIn to be the application or client. 

In order to post your tweets, LinkedIn will need authorization to access your Twitter information. 

Since both Twitter and LinkedIn have implemented OAuth, instead
of providing your credentials to the service provider and consumer every time you want to share this information across platforms, you can simply go into your LinkedIn settings and authorize Twitter. 
Doing so will send you to `api.twitter.com` to authorize LinkedIn to access your Twitter account

When you authorize LinkedIn to access your Twitter posts, Twitter generates a limited, time-based access token for LinkedIn.

LinkedIn then provides that token to Twitter to post on your behalf, and you don’t have to give LinkedIn your Twitter credentials.

![[Pasted image 20250104142835.png]]




