

## Web App Basics

Web applications function based on the client/server model: your web browser, the client, generates requests for resources and sends these to computers called web servers. 

In turn, these web servers send resources to the clients over a network. 

The **term web application** refers to ___software that is running on a web server___, such as Wikipedia, LinkedIn, Twitter, Gmail, GitHub, and more.

In particular, web applications are designed for end-user interactivity.

Whereas websites are typically read-only and provide one-way communication from the web server to the client, web applications allow communications to flow in both directions, from server to client and from client to server. 

For an end user to begin using a web application, a conversation must take place between the web browser and a web server.

The end ==user initiates this conversation by entering a URL into their browser address bar.==


## The URL

You probably already know that the uniform resource locator (URL) is the address used to locate unique resources on the internet. 

This URL consists of several components that you’ll find helpful to understand when crafting API requests in later chapters. 

All URLs include 
+ the protocol used, 
+ the hostname, 
+ the port, 
+ the path, and
+ any query parameters:
```
Protocol://hostname[:port number]/[path]/[?query][parameters]
```

**Protocols** are the sets of rules computers use to communicate. The primary protocols used within the URL are HTTP/HTTPS for web pages and FTP for file transfers.

**The port**, a number that specifies a communication channel, is only included if the host does not automatically resolve the request to the proper port. 

Typically, HTTP communications take place over port 80. 

HTTPS, the encrypted version of HTTP, uses port 443, and FTP uses port 21.

To access a web app that is hosted on a nonstandard port, you can include the port number in the URL, like so: 
`https://www.example.com:8443`. 
(Ports 8080 and 8443 are common alternatives for HTTP and HTTPS, respectively.)

**The file directory path** on the web server points to the location of the web pages and files specified in the URL. 

The path used in a URL is the same as a `filepath` used to locate files on a computer.

**The query** is an optional part of the URL used to perform functionality such as 
+ searching, 
+ filtering, and 
+ translating the language of the requested information. 

==The web application provider may also use the query strings
to track certain information such as the URL that referred you to the web page, your session ID, or your email. ==

It starts with a question mark and contains a string that the server is programmed to process. 

==Finally, the query parameters are the values that describe what should be done with the given query.==

For example, the query parameter `lang=en` following the query page?
might indicate to the web server that it should provide the requested page in English.

A query can contain multiple parameters separated by an
ampersand (&).

To make this information more concrete, consider the URL 

```
https://twitter.com/search?q=hacking&src=typed_query 
```

In this example, 
+ the protocol is `https`, 
+ the hostname is `twitter.com`, 
+ the path is search, the query is `?q` (which stands for query), the query parameter is hacking, and `src=typed_query` is a tracking parameter. 

This URL is automatically built whenever you click the search bar in the Twitter web app, type in the search term “hacking,”
and press ENTER. 

The browser is programmed to form the URL in a way that will be understood by the Twitter web server, and it collects some
tracking information in the form of the `src` parameter. 

The web server will receive the request for hacking content and respond with hacking-related information.


## HTTP Requests

![[Pasted image 20241231205953.png]]

To make this information more concrete, consider the URL 
```
https://twitter.com/search?q=hacking&src=typed_query
```
In this example, 
+ the protocol is `https`, 
+ the hostname is `twitter.com`, 
+ the path is `search`, 
+ the query is ?q (which stands for query), the query parameter is `hacking`, 
+ and `src=typed_query` is a tracking parameter.

The browser is programmed to form the URL in a way that will be understood by the Twitter web server, and it collects some
tracking information in the form of the `src` parameter.



## HTTP Responses

The type of response depends on the availability of the
resource, the user’s authorization to access the resource, the health of the web server, and other factors.

![[Pasted image 20241231210116.png]]

HTTP response headers often provide the browser with instructions for handling the response and security requirements. 

The set-cookie header **is another indication that the authentication request was successful**, because the web server has issued a cookie that includes an `auth_token` which the client can use to access certain resources.

**Web authentication** is the process of proving your identity to a web server.
Common forms of authentication include providing a password, token, or bio-metric information (such as a fingerprint).



## HTTP Status Codes

When a web server responds to a request, it issues a response status code, along with a response message.

==Since web APIs primarily function using HTTP==, it is important to
understand the sorts of response codes you should expect to receive from a web server.

Mozilla’s Web Docs 
(https://developer.mozilla.org/en-US/docs/Web/HTTP)



## HTTP Methods

HTTP methods request information from a web server. Also known as HTTP verbs, the HTTP methods include 
+ GET, 
+ PUT, 
+ POST, 
+ HEAD, 
+ PATCH, 
+ OPTIONS, 
+ TRACE, and 
+ DELETE.

GET and POST are the two most commonly used request methods. 

**The GET request** is used to obtain resources from a web server. 

**The POST** request is used to submit data to a web server.

**PUT requests**
+ PUT requests instruct the web server to store submitted data under the requested URL. 
+ PUT is primarily used to send a resource to a web server.
+ If a server accepts a PUT request, it will add the resource or completely replace the existing resource. 
+ If a PUT request is successful, a new URL should be created. 
+ If the same PUT request is submitted again, the results should remain the same.

**HEAD requests** 
+ HEAD requests are similar to GET requests, except they request the HTTP headers only, excluding the message body.
+ This request is a quick way to obtain information about server status and ==to see if a given URL works.==

**PATCH requests**
+ PATCH requests are used to partially update resources with the submitted data. 
+ PATCH requests are likely only available if an HTTP response includes the Accept-Patch header.

**OPTIONS requests**
+ OPTIONS requests are a way for the client to identify all the request methods allowed from a given web server.
+ If the web server responds to an OPTIONS request, it should respond with all allowed request options.

**TRACE requests**
+ TRACE requests are primarily used for ==debugging input sent from the client to the server==. 
+ TRACE asks the server to echo back the client’s original request, which could reveal that a mechanism is altering the client’s request before it is processed by the server.

**CONNECT requests**
+ CONNECT requests initiate a two-way network connection.
+ When allowed, this request would create a proxy tunnel between the browser and web server.

**DELETE requests** ask that the server remove a given resource.


### [Idempotent ](https://translate.google.com/?sl=en&tl=ar&text=Idempotent%20&op=translate)

Some methods are idempotent, ==which means they can be used to send the same request multiple times without changing the state of a resource on a web server==. 

For example, if you perform the operation of turning on a light, then the light turns on. 

When the switch is already on and you try to flip the switch on again, it remains on—nothing changes. 

GET, HEAD, PUT, OPTIONS, and DELETE are idempotent.


### Non-idempotent

non-idempotent methods can dynamically change the results of a resource on a server. 

Non-idempotent methods include POST, PATCH, and CONNECT. 

POST is used to create new resources on a web server, so if a POST request is submitted 10 times, there will be 10 new resources on the web server. 

By contrast, if an idempotent method like PUT, typically used to update a resource, is requested 10 times, ==a single resource will be overwritten 10 times.==

==DELETE is also idempotent, because if the request to delete a resource was sent 10 times, the resource would be deleted only once.==


## Statefull and Stateless HTTP

==HTTP is a **stateless** protocol==, meaning the server doesn’t keep track of information between requests. 

However, for users to have a persistent and consistent experience with a web application, the web server needs to remember something about the HTTP session with that client.

For example, if a user is logged in to their account and adds several items to the shopping cart, the web application needs to keep track of the state of the end user’s cart.

Otherwise, every time the user navigated to a different web page, the cart would empty again.

**A state-full connection** allows the server to track the client’s actions, profile, images, preferences, and so on.

**State-full connections** use small text files, called ==cookies==, to store information on the client side. 

**Cookies** may store site specific settings, security settings, and authentication-related information.
[Meanwhile](https://translate.google.com/?sl=en&tl=ar&text=Meanwhile&op=translate), the server often stores information on itself, in a cache, or on back-end databases.

To continue their sessions, browsers include the stored
cookies in requests to the server, and when hacking web applications, an attacker can [impersonate](https://translate.google.com/?sl=en&tl=ar&text=impersonate&op=translate) an end user by stealing or forging their cookies.


When a ==state== is maintained between a client and a server, that relationship exists only between the specific browser and the server used when the state was created.
If a user switches from, say, using a browser on one computer
to using the browser on their mobile device, the client would need to re-authenticate and create a ==new state== with the server.

Also, state-full connections require the client to continuously send requests to the server. 
Challenges start to arise when many clients are maintaining state with the same server.
The server can only handle as many state-full connections as allowed by its computing resources. 
This is much more readily solved by stateless applications.


### Stateless communications

Stateless communications eliminate the need for the server resources required to manage sessions. 

In stateless communications, the server doesn’t store session information, and ==**every** stateless request sent must contain all the information necessary for the web server to recognize that the requestor is authorized to access the given resources.== 
These stateless requests can include a key or some form of authorization header to maintain an experience similar to that of a state-full connection. 

The connections do not store session data on the web app server; instead, they leverage back-end databases.

In our shopping cart example, a stateless application could track
the contents of a user’s cart by updating the database or cache based on requests that contain a certain token.

Any number of servers can be used to handle requests as long as all the necessary information is included within the request and that information is accessible on the backend databases.

**==API communications are stateless==**



## Web Server Databases

Databases allow servers to store and quickly provide resources to clients.

For example, any social media platform that allows you to upload status updates, photos, and videos is definitely using databases to save all that content. 

The social media platform could be maintaining those databases on its own; alternatively, the databases could be provided to the platform as a service.

### Front end

Typically, a web application will store user resources by passing the resources from front-end code to back-end databases. 

The front-end of a web application, which is the part of a web application that a user interacts with,determines its look and feel and includes its buttons, links, videos, and fonts.

front-end code usually includes 
+ HTML, 
+ CSS, 
+ and JavaScript. 

In addition, the front-end could include web application frameworks like 
+ `AngularJS`, 
+ `ReactJS`, 
+ and `Bootstrap`, to name a few.

### Back-end

The back-end consists of the technologies that
the front-end needs to function. 

It includes the server, the application, and any databases. 

Back-end programming languages include 
+ JavaScript, 
+ Python,
+ Ruby, 
+ Golang, 
+ PHP, 
+ Java, 
+ C#, 
+ and Perl, to name a handful.


### Attack surface
In a secure web application, there should be no direct interaction between a user and the back-end database. 

Direct access to a database would remove a layer of defense and open up the database to additional attacks.

When exposing technologies to end users, a web application provider expands their potential for attack, a metric known as the ==**attack surface**==.

==**Limiting** direct access to a database shrinks the size of the attack surface.==


### SQL

**==Structured Query Language (SQL)==** databases are relational databases in which the data is organized in tables. 

The table’s rows, called records, identify the data type, such as username, email address, or privilege level. 

Its columns are the data’s attributes and could include all of the different usernames, email addresses, and privilege levels.

To retrieve data from a SQL database, an application must craft a SQL query.

SQL databases include 
+ MySQL, 
+ Microsoft SQL Server, 
+ PostgreSQL, 
+ Oracle, 
+ and MariaDB, among others.


### NoSQL

NoSQL databases, also known as distributed databases, are non-relational, meaning they don’t follow the structures of relational databases. 

NoSQL databases are ==**typically open-source tools**== that handle unstructured data and store data as documents. 

Instead of relationships, ==NoSQL databases store information as keys and values==. 

Unlike SQL databases, each type of NoSQL database will have its own unique structures, modes of querying, vulnerabilities, and exploits.

NoSQL databases include 
+ MongoDB, 
+ Couchbase, 
+ Cassandra, 
+ IBM Domino, 
+ Oracle NoSQL Database, 
+ Redis, 
+ and Elasticsearch, among others.




## How APIs Fit into the Picture

A web application can be made more powerful if it can use the power of other applications. 

Application programming interfaces (APIs) comprise a technology that facilitates communications between separate applications.

By using HTTP, web APIs can take advantage of the protocol’s standardized methods, status codes, and client/server relationship, allowing developers to write code that can automatically handle the data.


# For More

If you would like additional resources about web applications, I highly suggest 
+ The Web Application Hackers Handbook (Wiley, 2011), 
+ Web Application Security (O’Reilly, 2020), 
+ Web Security for Developers (No Starch Press, 2020), 
+ and The Tangled Web (No Starch Press, 2011).