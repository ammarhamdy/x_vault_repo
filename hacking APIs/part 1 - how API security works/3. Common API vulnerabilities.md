

Covering most of the vulnerabilities included in the ==Open Web
Application Security Project (OWASP)== API Security Top 10 list


# OWASP API SECURITY TOP 10

OWASP is a nonprofit foundation that creates free content and tools aimed at securing web applications. 

Due to the increasing prevalence of API vulnerabilities, OWASP released the OWASP API Security Top 10, a list of the 10 most common API vulnerabilities, at the end of 2019. 

Check out the project, which was led by API security experts `Inon Shkedy` and `Erez Yalon`, at: 
https://owasp.org/www-project-api-security. 

We will demonstrate how the vulnerabilities described in the OWASP API Security Top 10 have been exploited in major breaches and bug bounty findings.


# Information [Disclosure](https://translate.google.com/?sl=en&tl=ar&text=Disclosure&op=translate)

When an API and its supporting software share sensitive information with unprivileged users, the API has an information disclosure vulnerability.

Information may be disclosed in API responses or public sources such as code repositories, search results, news, social media, the target’s website, and public API directories.


# Broken Object Level Authorization

BOLA vulnerabilities occur when an API provider allows an API consumer access to resources they are not authorized to access.

If an API endpoint does not have object-level access controls, it won’t perform checks to make sure users can only access their own resources. When these controls are missing, User A will be able to successfully request User B’s resources.

In general, you can test for BOLAs by understanding how an API’s
resources are structured and attempting to access resources you shouldn’t be able to access.


# Broken User Authentication

Broken user authentication refers to any weakness within the API authentication process. 

These vulnerabilities typically occur when an API provider either doesn’t implement an authentication protection mechanism or
implements a mechanism incorrectly.

```
“The future of digital systems is complexity, and complexity is the worst enemy of security.”
```

As a consequence, the registration process used to obtain an API token, the token handling, and the system that generates the token could all have their own sets of weaknesses.

To determine if the token generation process is weak, for example, we could collect a sampling of tokens and analyze them for similarities.

The other authentication processes that could have their own set of vulnerabilities include aspects of the registration system, such as the password reset and multifactor authentication features.

Well, if the API allowed you to make as many requests as you wanted, you’d only have to make one million requests in order to guess the code and reset any user’s password. 

==**A four-digit code would require only 10,000 requests**==.
```
10 * 10 * 10 * 10  = 10,000
```



# Excessive Data [Exposure](https://translate.google.com/?sl=en&tl=ar&text=Exposure&op=translate)

This often occurs when the provider expects the API consumer to filter results; in other words, when a consumer requests specific information, the provider might respond with all sorts of information, assuming the consumer will then remove any data they don’t need from the response.

All you need to do to detect excessive data exposure is test your
target API endpoints and review the information sent in response.



# Lack of Resources and Rate Limiting

Rate limiting plays an important role in the monetization and
availability of APIs. Without limiting the number of requests consumers can make, an API provider’s infrastructure could be overwhelmed by the requests.

Too many requests without enough resources will lead to the provider’s systems crashing and becoming unavailable—a denial of service (DoS) state.

Besides potentially DoS-ing an API, an attacker who bypasses rate limits can cause additional costs for the API provider. Many API providers monetize their APIs by limiting requests and allowing paid customers to request more information. 

RapidAPI, for example, allows for 500 requests per month for
free but 1,000 requests per month for paying customers.

When testing an API that is supposed to have rate limiting, ==the first thing you should check is that rate limiting works, and you can do so by sending a barrage of requests to the API==. 

If rate limiting is functioning, you should receive some sort of response informing you that you’re no longer able to make additional requests, ==usually in the form of an HTTP **429** status code==.

==Once you are restricted from making additional requests, it’s time
to attempt to see how rate limiting is enforced==. 
Can you bypass it by adding or removing a parameter, using a different client, or altering your IP address?



# Broken Function Level Authorization

Broken function level authorization (BFLA) is a vulnerability where a user of one role or group is able to access the API functionality of another role or group.

BFLA can be a lateral move, where you use the functions of a similarly privileged group, or it could be a privilege escalation, where you are able to use the functions of a more privileged
group.

==A BFLA is present if you are able to use the functionality of another
privilege level or group==.

BFLA is similar to BOLA, except instead of an authorization problem involving accessing resources, it is an authorization problem for performing actions.

For example, consider a vulnerable banking API. When a BOLA vulnerability is present in the API, you might be able to access the information of other accounts, such as payment histories, usernames, email addresses, and account numbers. 
If a BFLA vulnerability is present, you might be able to transfer money and actually update the account information.

==BOLA is about unauthorized access, whereas BFLA is about unauthorized actions==.

When hunting for BFLA, look for any functionality you could use to
your advantage, including altering user accounts, accessing user resources, and gaining access to restricted endpoints.

==The easiest way to discover BFLA is to find administrative API documentation and send requests as an unprivileged user that test admin functions and capabilities==.



# Mass Assignment

Mass assignment occurs when an API consumer includes more parameters in their requests than the application intended and the application adds these parameters to code variables or internal objects. 

In this situation, a consumer may be able to edit object properties or [escalate](https://translate.google.com/?sl=en&tl=ar&text=escalate&op=translate) privileges.

**For example**, an application might have account update functionality that the user should use only to update their username, password, and address. 
If the consumer can include other parameters in a request related to their account, such as the account privilege level or sensitive information like account balances, and the application accepts those parameters without checking them against a whitelist of permitted actions, the consumer could take advantage of this weakness to change these values.

==You can discover mass assignment vulnerabilities by finding interesting parameters in API documentation and then adding those parameters to a request==.
**==Additionally, you can guess parameters or fuzz them in API requests==**.



# Security Misconfigurations

Security misconfigurations include all the mistakes developers could make within the supporting security configurations of an API. 
If a security misconfiguration is severe enough, it can lead to sensitive information exposure or a complete system takeover.

A lack of input [sanitization](https://translate.google.com/?sl=en&tl=ar&text=sanitization&op=translate) can allow attackers to upload malicious payloads to the server.

APIs often play a key role in automating processes, so imagine being able to upload payloads that the server automatically processes into a format that could be remotely executed or executed by an unsuspecting end user.

Any API providing sensitive information to consumers should use
**==Transport Layer Security (TLS)==** to encrypt the data. 
Even if the API is only provided internally, privately, or at a partner level, using TLS, the protocol that encrypts HTTPS traffic, is one of the most basic ways to ensure that API requests and responses are protected when being passed across a network.

Lastly, if an API provider allows unnecessary HTTP methods, there is an increased risk that the application won’t handle these methods properly or will result in sensitive information disclosure.

You can detect several of these security misconfigurations with web application vulnerability scanners such as 
+ **`Nessus`**, 
+ **`Qualys`**, 
+ **`OWASP ZAP`**, 
+ and **`Nikto`**. 
These scanners will automatically check 
+ the web server version information, 
+ headers, 
+ cookies, 
+ transit encryption configuration, 
+ and parameters
to see if expected security measures are missing. 

You can also check for these security misconfigurations manually, if you know what you are looking for, by inspecting the headers, SSL certificate, cookies, and parameters.




# Injections

Injection flaws exist when a request is passed to the API’s supporting infrastructure and the API provider doesn’t filter the input to remove unwanted characters (a process known as input [sanitization](https://translate.google.com/?sl=en&tl=ar&text=sanitization&op=translate)).

As a result, the infrastructure might treat data from the request as code and run it. 

When this sort of flaw is present, you’ll be able to conduct injection attacks such as SQL injection, NoSQL injection, and system command injection.

Verbose error messaging, HTTP response codes, and unexpected API behavior can all be clues that you may have discovered an injection flaw.

Say, **for example**, you were to send `OR 1=0--` as an address in an account registration process. 
The API may pass that payload directly to the backend SQL database, where the `OR 1=0` statement would fail (because 1 does not equal 0), causing some SQL error:

```
POST /api/v1/register HTTP 1.1
Host: example.com
--snip--
{
"Fname": "hAPI",
"Lname": "Hacker",
"Address": "' OR 1=0--",
}
```

==Any response directly from a database or the supporting system is a clear indicator that there is an injection vulnerability==.

directory traversal attacks, injection attacks have been around for decades, so there are many standard security controls to protect API providers from them.



# [Improper](https://translate.google.com/?sl=en&tl=ar&text=Improper&op=translate) Assets Management

Improper assets management takes place when an organization exposes APIs that are either retired or still in development. 

As with any software, old API versions are more likely to contain vulnerabilities because they are no longer being patched and upgraded.

**==discovering an improper assets management vulnerability is only the first step toward further exploitation of an API==**.

You can discover improper assets management by paying close attention to outdated API documentation, changelogs, and version history on repositories.



# Business Logic Vulnerabilities

Business logic vulnerabilities (also known as business logic flaws, or BLFs) are intended features of an application that attackers can use maliciously. 

**For example**, if an API has an upload feature that doesn’t validate encoded payloads, a user could upload any file as long as it was encoded. 

This would allow end users to upload and execute arbitrary code, including malicious
payloads.